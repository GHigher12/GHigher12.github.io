<!DOCTYPE html>
<html>
<!-- meta/link... -->




<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>激光slam学习记录一 | Ychui&#39;s Blog</title>

  <link rel="icon" type="image/svg+xml" href="/blog.svg">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
        <script src="/js/valine/index.js"></script>
    

    <!-- import link -->
    
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Ychui's Blog" type="application/atom+xml">
</head>


  <!-- 依赖于jquery和vue -->
  
    
<script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>

      

          
            
<script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>

              

                  <body>
                    <!-- 预加载动画 -->
                    <!-- 页面预加载动画 -->

<div id='loader'>
  <link rel="stylesheet" href="/js/loaded/index.css" >
  <div class="loading-left-bg"></div>
  <div class="loading-right-bg"></div>
  <div class="spinner-box">
    <div class="configure-border-1">
      <div class="configure-core"></div>
    </div>
    <div class="configure-border-2">
      <div class="configure-core"></div>
    </div>
    <div class="loading-word">加载中...</div>
  </div>
</div>

<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
  
</script>


                      <!-- 判断是否为暗黑风格 -->
                      <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

                        <!-- 需要在上面加载的js -->
                        <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (href, before, media, attributes) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


                          <div id="safearea">
                            <main class="main" id="pjax-container">
                              <!-- 头部导航 -->
                              
<header class="header   " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/touxiang.png" class="lazyload placeholder" data-srcset="/medias/touxiang.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="logo">
      <h3 class="drawer-box-head_title">Ychui&#39;s Blog</h3>
      <h5 class="drawer-box-head_desc"></h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/" class="drawer-menu-item-link">
                  
                    <i class="fas fa-home" aria-hidden="true"></i>
                  
                  <span class="name">首页</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/archives" class="drawer-menu-item-link">
                  
                    <i class="fas fa-archive" aria-hidden="true"></i>
                  
                  <span class="name">归档</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/tags" class="drawer-menu-item-link">
                  
                    <i class="fas fa-tags" aria-hidden="true"></i>
                  
                  <span class="name">标签</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/categories" class="drawer-menu-item-link">
                  
                    <i class="fas fa-bookmark" aria-hidden="true"></i>
                  
                  <span class="name">分类</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/about" class="drawer-menu-item-link">
                  
                    <i class="fas fa-user" aria-hidden="true"></i>
                  
                  <span class="name">关于</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/" class="drawer-menu-item-link">
                  
                    <i class="fas fa-chevron-circle-down" aria-hidden="true"></i>
                  
                  <span class="name">更多</span>
                </a>
              
            </li>
          
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/GHigher12">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/touxiang.png" class="lazyload placeholder" data-srcset="/medias/touxiang.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="logo">
        </div>
      
      <a href="/" class="logo">Ychui&#39;s Blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/" class="menu-item-link" title="首页">
                  
                    <i class="fas fa-home" aria-hidden="true"></i>
                  
                  <span class="name">首页</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/archives" class="menu-item-link" title="归档">
                  
                    <i class="fas fa-archive" aria-hidden="true"></i>
                  
                  <span class="name">归档</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/tags" class="menu-item-link" title="标签">
                  
                    <i class="fas fa-tags" aria-hidden="true"></i>
                  
                  <span class="name">标签</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/categories" class="menu-item-link" title="分类">
                  
                    <i class="fas fa-bookmark" aria-hidden="true"></i>
                  
                  <span class="name">分类</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/about" class="menu-item-link" title="关于">
                  
                    <i class="fas fa-user" aria-hidden="true"></i>
                  
                  <span class="name">关于</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/" class="menu-item-link" title="更多">
                  
                    <i class="fas fa-chevron-circle-down" aria-hidden="true"></i>
                  
                  <span class="name">更多</span>
                </a>
              
            </li>
          
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/GHigher12" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
    <div id="he-plugin-simple"></div>
    <script>
      WIDGET = {
        CONFIG: {
          "modules": "012",
          "background": 5,
          "tmpColor": "4A4A4A",
          "tmpSize": 16,
          "cityColor": "4A4A4A",
          "citySize": 16,
          "aqiSize": 16,
          "weatherIconSize": 24,
          "alertIconSize": 18,
          "padding": "10px 10px 10px 10px",
          "shadow": "1",
          "language": "auto",
          "borderRadius": 5,
          "fixed": "false",
          "vertical": "middle",
          "horizontal": "center",
          "key": "2784dd3fcb1e4f0f9a9b579bf69641f2"
        }
      }
    </script>
    <script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script> 
    
</header>
                                <!-- 内容区域 -->
                                
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('/medias/5.jpg')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        激光slam学习记录一
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2025-11-14 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/SLAM/" class="post-detail-header_category">
              SLAM
            </a>
          
        </span>
      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="row justify-position" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="激光SLAM学习"><a href="#激光SLAM学习" class="headerlink" title="激光SLAM学习"></a>激光SLAM学习</h1><h2 id="IMU"><a href="#IMU" class="headerlink" title="IMU"></a>IMU</h2><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/3_2IMU.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/3_2IMU.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h3 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h3><p>噪声运动模型</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907161811178.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907161811178.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250907161811178"></p>
<ul>
<li><strong>测量噪声</strong>：是 “零均值白高斯噪声”—— 干扰是随机的、没有固定偏向，而且不同时刻的干扰互不影响。可以用 “<strong>高斯过程</strong>” 描述，方便从连续时间（比如实时测量）推导到离散时间（比如每隔 0.1 秒采样一次）的噪声。</li>
<li><strong>零偏（固有偏差）</strong>：是 “随机游走”（类似 “<strong>布朗运动</strong>”）—— 零偏会从初始值开始，随机地慢慢 “飘移”。比如加速度计的零偏ba，它的变化率（飘移的快慢）也是一种高斯噪声；陀螺仪的零偏bg同理。</li>
</ul>
<p>陀螺仪和加速度的离散噪声模型</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907161937431.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907161937431.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250907161937431"></p>
<ul>
<li>测量噪声，在整个运动模型看来是<strong>角度随机游走</strong>和<strong>速度随机游走</strong>。</li>
<li>零偏随机游走方差，手册里经常给出的是<strong>零偏重复性</strong>和<strong>运行时偏置稳定性</strong>来代替。</li>
</ul>
<h3 id="航迹推算"><a href="#航迹推算" class="headerlink" title="航迹推算"></a>航迹推算</h3><p>测量模型代入运动学方程</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907162145641.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907162145641.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250907162145641"></p>
<p>积分</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907162737316.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907162737316.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250907162737316"></p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907162731552.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250907162731552.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250907162731552"></p>
<h2 id="GNSS"><a href="#GNSS" class="headerlink" title="GNSS"></a>GNSS</h2><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/3_3GNSS.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/3_3GNSS.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h2 id="ESKF"><a href="#ESKF" class="headerlink" title="ESKF"></a>ESKF</h2><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/3_4 ESKF.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/3_4 ESKF.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h3 id="雅可比矩阵"><a href="#雅可比矩阵" class="headerlink" title="雅可比矩阵"></a>雅可比矩阵</h3><p><strong>核心作用</strong>：描述 “输入微小变化” 如何影响 “输出的每一个维度”，是<strong>向量函数的 “一阶导数”</strong>。偏导数</p>
<h3 id="海森矩阵"><a href="#海森矩阵" class="headerlink" title="海森矩阵"></a>海森矩阵</h3><p><strong>核心作用</strong>：描述函数的<strong>局部曲率</strong>（弯曲程度），是<strong>标量函数的 “二阶导数”</strong>。向量函数的二阶导数是<strong>多个海森矩阵组成的张量 / 分块结构</strong>。</p>
<h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>总体协方差</p>
<script type="math/tex; mode=display">
\text{Cov}(X,Y) = \mathbb{E}\left[(X - \mu_X)(Y - \mu_Y)\right]</script><p>样本协方差</p>
<script type="math/tex; mode=display">
\text{Cov}(X,Y) \approx \frac{1}{n-1} \sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})</script><p>协方差矩阵</p>
<script type="math/tex; mode=display">
\Sigma = \begin{pmatrix}
\text{Cov}(X_1,X_1) & \text{Cov}(X_1,X_2) & \dots & \text{Cov}(X_1,X_p) \\
\text{Cov}(X_2,X_1) & \text{Cov}(X_2,X_2) & \dots & \text{Cov}(X_2,X_p) \\
\vdots & \vdots & \ddots & \vdots \\
\text{Cov}(X_p,X_1) & \text{Cov}(X_p,X_2) & \dots & \text{Cov}(X_p,X_p)
\end{pmatrix}</script><p>相关系数</p>
<script type="math/tex; mode=display">
\rho_{XY} = \frac{\text{Cov}(X,Y)}{\sigma_X \sigma_Y}</script><p>方差计算</p>
<script type="math/tex; mode=display">
Var (aX+bY) = a²VarX + b²VarY + 2abCov (X,Y)</script><p>在机器人、导航等领域，卡尔曼滤波用<strong>协方差矩阵描述 “状态不确定性” 的传播</strong>：</p>
<ul>
<li>每次传感器测量后，协方差矩阵更新 “当前状态的置信度”；</li>
<li>协方差越小，说明状态估计越准确。</li>
</ul>
<p>协方差只能衡量<strong>线性关系</strong>，对非线性关系无能为力。</p>
<h3 id="名义状态变量"><a href="#名义状态变量" class="headerlink" title="名义状态变量"></a>名义状态变量</h3><p>当 IMU（惯性测量传感器）数据到来时，先 “不考虑噪声”，直接把数据积分到<strong>名义状态</strong>里（相当于按 “理想无干扰” 的情况推算位置、姿态）。运动过程中，名义状态靠 IMU 数据持续推算；</p>
<h3 id="误差状态变量"><a href="#误差状态变量" class="headerlink" title="误差状态变量"></a>误差状态变量</h3><p>现实有噪声（比如传感器误差、外界干扰），所以名义状态会慢慢 “跑偏”，这时候<strong>误差状态</strong>就记录 “跑偏的程度”。误差状态会因噪声影响越来越大，ESKF 能用 “均值 + 协方差”（类似 “统计描述误差有多大、多分散”）来刻画误差的扩大。</p>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><h4 id="第一步：明确“状态拆分”逻辑"><a href="#第一步：明确“状态拆分”逻辑" class="headerlink" title="第一步：明确“状态拆分”逻辑"></a>第一步：明确“状态拆分”逻辑</h4><p>把<strong>真实状态</strong>（比如机器人的实际位置、速度、旋转等）拆成两部分： </p>
<p><strong>名义状态</strong>（不带下标，如( $\boldsymbol{p}$ )、( $\boldsymbol{v}$ )、( $\boldsymbol{R} $)）：“理想的、无噪声的状态”（类比：导航告诉你“应该在的位置”）。 </p>
<p><strong>误差状态</strong>（如( $\delta \boldsymbol{p}$ )、( $\delta \boldsymbol{v}$ )、($ \delta \boldsymbol{R} $)）：“真实状态与名义状态的偏差”（类比：你实际位置和“应该位置”的差距）。 </p>
<p>所以真实状态 = 名义状态 + 误差状态</p>
<script type="math/tex; mode=display">
\begin{align*}
\boldsymbol{p}_t &= \boldsymbol{p} + \delta \boldsymbol{p}, \\
\boldsymbol{v}_t &= \boldsymbol{v} + \delta \boldsymbol{v}, \\
\boldsymbol{R}_t &= \boldsymbol{R} \delta \boldsymbol{R} \quad \text{或} \quad \boldsymbol{q}_t = \boldsymbol{q} \delta \boldsymbol{q}, \\
\boldsymbol{b}_{gt} &= \boldsymbol{b}_g + \delta \boldsymbol{b}_g, \\
\boldsymbol{b}_{at} &= \boldsymbol{b}_a + \delta \boldsymbol{b}_a, \\
\boldsymbol{g}_t &= \boldsymbol{g} + \delta \boldsymbol{g}.
\end{align*}</script><h4 id="第二步：处理“旋转”的非线性"><a href="#第二步：处理“旋转”的非线性" class="headerlink" title="第二步：处理“旋转”的非线性"></a>第二步：处理“旋转”的非线性</h4><p>李群&amp;李代数旋转（比如旋转矩阵( $\boldsymbol{R}$ )）属于<strong>李群（( SO(3) )）</strong>——它的运算（矩阵乘法）是非线性的，直接处理“旋转误差”很麻烦。</p>
<p>这时候用<strong>李代数($ \mathfrak{so}(3)$</strong> ：李代数是“旋转的微小增量（三维向量( $\delta \boldsymbol{\theta} $）”，是<strong>线性空间</strong>（可以像普通向量一样做加减、数乘）。通过“指数映射”$ \text{Exp}(\delta \boldsymbol{\theta}) $，能把“李代数（三维向量）”转换成“李群（旋转矩阵( $\delta \boldsymbol{R}$）”。 通俗说：旋转的“大变化”是非线性的，但“微小偏差”可以用“线性的三维向量”描述，再通过“指数映射”转换成旋转矩阵的偏差。这样就把旋转的“非线性误差”变成了“线性的李代数向量”，方便后续计算。  </p>
<p>真实旋转矩阵可表示为「名义旋转矩阵 R」与「误差旋转的指数映射 Exp(δθ)」的乘积：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}_t = \boldsymbol{R} \text{Exp}(\delta \theta)</script><p>两侧求导：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}_t = \dot{\boldsymbol{R}} \text{Exp}(\delta \theta) + \boldsymbol{R} \dot{\text{Exp}}(\delta \theta)</script><p>指数映射 Exp(δθ) 对时间的导数满足<strong>李群微分规则</strong>（$\dot R=\dot{\text{Exp}}(\phi^\wedge)\dot \phi^\wedge$）：</p>
<script type="math/tex; mode=display">
\dot{\text{Exp}}(\delta \theta) = \text{Exp}(\delta \theta) (\delta \dot{\theta})^\wedge</script><p>代入</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}_t = \boldsymbol{R} (\tilde{\omega} - \boldsymbol{b}_g)^\wedge \text{Exp}(\delta \theta) + \boldsymbol{R} \text{Exp}(\delta \theta) (\delta \dot{\theta})^\wedge \tag{3.30}</script><script type="math/tex; mode=display">
\dot{\boldsymbol{R}}_t = \boldsymbol{R} \text{Exp}(\delta \theta) (\tilde{\omega} - \boldsymbol{b}_{gt} - \eta_g)^\wedge \tag{3.31}</script><p>由于式 (3.30) 和 (3.31) 左边都是 R˙t，因此右边相等。两边左乘 R−1（因 R 是正交矩阵，R−1=R⊤），消去 R 后整理得：</p>
<script type="math/tex; mode=display">
\text{Exp}(\delta \theta) (\delta \dot{\theta})^\wedge = \text{Exp}(\delta \theta) (\tilde{\omega} - \boldsymbol{b}_{gt} - \eta_g)^\wedge - (\tilde{\omega} - \boldsymbol{b}_g)^\wedge \text{Exp}(\delta \theta) \tag{3.32}</script><p>旋转矩阵群 SO(3) 满足<strong>伴随性质</strong>：对任意 R∈SO(3) 和向量 ϕ，有</p>
<script type="math/tex; mode=display">
\phi^\wedge \boldsymbol{R} = \boldsymbol{R} (\boldsymbol{R}^\top \phi)^\wedge \tag{3.33}</script><script type="math/tex; mode=display">
\begin{align*}
\text{Exp}(\delta\theta) \delta \dot{\theta}^\wedge &= \text{Exp}(\delta\theta) \left( \tilde{\omega} - b_{gt} - \eta_g \right)^\wedge - \text{Exp}(\delta\theta) \left( \text{Exp}(-\delta\theta) \left( \tilde{\omega} - b_g \right) \right)^\wedge \\
&= \text{Exp}(\delta\theta) \left[ \left( \tilde{\omega} - b_{gt} - \eta_g \right)^\wedge - \left( \text{Exp}(-\delta\theta) \left( \tilde{\omega} - b_g \right) \right)^\wedge \right] \\
&\approx \text{Exp}(\delta\theta) \left[ \left( \tilde{\omega} - b_{gt} - \eta_g \right)^\wedge - \left( \left( I - \delta\theta^\wedge \right) \left( \tilde{\omega} - b_g \right) \right)^\wedge \right] \\
&= \text{Exp}(\delta\theta) \left[ b_g - b_{gt} - \eta_g + \delta\theta^\wedge \tilde{\omega} - \delta\theta^\wedge b_g \right]^\wedge \\
&= \text{Exp}(\delta\theta) \left[ \left( -\tilde{\omega} + b_g \right)^\wedge \delta\theta - \delta b_g - \eta_g \right]^\wedge.
\end{align*}</script><p>其中≈处使用<strong>一阶泰勒展开</strong></p>
<script type="math/tex; mode=display">
\text{Exp}(-\delta\theta) \approx  I - \delta\theta^\wedge</script><p>最终误差角速度方程</p>
<script type="math/tex; mode=display">
\delta \dot{\theta} \approx -(\tilde{\omega} - b_g)^\wedge \delta\theta - \delta b_g - \eta_g</script><h4 id="第三步：对“真实运动方程”线性化"><a href="#第三步：对“真实运动方程”线性化" class="headerlink" title="第三步：对“真实运动方程”线性化"></a>第三步：对“真实运动方程”线性化</h4><p>真实状态的运动是<strong>非线性的</strong>（比如旋转的乘法、加速度受旋转的变换等），但因为“误差状态是小量”，所以可以用<strong>泰勒一阶展开</strong>（线性化）——把复杂的非线性关系，在“名义状态附近的小范围”近似成“直线关系”（线性关系），忽略高阶小量。 以“位置和速度”为例： </p>
<ul>
<li>真实位置的导数是真实速度：($ \dot{\boldsymbol{p}}_t = \boldsymbol{v}_t $) </li>
<li>代入“真实=名义+误差”：( $\dot{\boldsymbol{p}} + \delta \dot{\boldsymbol{p}} = \boldsymbol{v} + \delta \boldsymbol{v}$ ) </li>
<li>名义状态的导数是名义速度：( $\dot{\boldsymbol{p}} = \boldsymbol{v} $)</li>
<li>所以化简得：( $\delta \dot{\boldsymbol{p}} = \delta \boldsymbol{v}$ )（位置误差的变化率=速度误差）  </li>
</ul>
<p>再以“速度和加速度”为例（加速度受旋转、重力、传感器偏置影响）： 真实加速度的计算涉及“旋转矩阵对加速度的变换”“偏置的影响”“重力的影响”。把这些“真实项”用“名义+误差”展开，再因为“误差是小量”，忽略高阶项，最终能得到<strong>速度误差的线性微分方程</strong>（形式为“速度误差的变化率 = 雅克比矩阵×误差 + 噪声”，雅克比是线性化的系数）。  </p>
<h4 id="第四步：推导各误差状态的微分方程"><a href="#第四步：推导各误差状态的微分方程" class="headerlink" title="第四步：推导各误差状态的微分方程"></a>第四步：推导各误差状态的微分方程</h4><p>对位置、速度、旋转（李代数形式）、传感器偏置、重力等，逐一重复“线性化真实运动方程”的过程，最终得到<strong>所有误差状态的变化率（导数）与误差自身、输入噪声的线性关系</strong>，这就是<strong>误差状态方程</strong>。 比如： </p>
<ul>
<li>传感器偏置的误差（如陀螺仪偏置( $\delta \boldsymbol{b}_g$ )），通常假设“偏置缓慢变化”，其误差方程可能是“($ \delta \dot{\boldsymbol{b}}_g = \text{随机噪声}$ )”（简化模型）。 </li>
<li>重力的误差，若局部区域重力变化小，也可做简化假设（如误差变化率为0）。  </li>
</ul>
<p>把误差变量的运动学方程整理如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta \dot{\boldsymbol{p}} &= \delta \boldsymbol{v}, \\
\delta \dot{\boldsymbol{v}} &= -\boldsymbol{R} (\tilde{\boldsymbol{a}} - \boldsymbol{b}_a)^\wedge \delta \boldsymbol{\theta} - \boldsymbol{R} \delta \boldsymbol{b}_a - \boldsymbol{\eta}_a + \delta \boldsymbol{g}, \\
\delta \dot{\boldsymbol{\theta}} &= -(\tilde{\boldsymbol{\omega}} - \boldsymbol{b}_g)^\wedge \delta \boldsymbol{\theta} - \delta \boldsymbol{b}_g - \boldsymbol{\eta}_g, \\
\delta \dot{\boldsymbol{b}}_g &= \boldsymbol{\eta}_{bg}, \\
\delta \dot{\boldsymbol{b}}_a &= \boldsymbol{\eta}_{ba}, \\
\delta \dot{\boldsymbol{g}} &= 0.
\end{align*}</script><h4 id="核心原理总结"><a href="#核心原理总结" class="headerlink" title="核心原理总结"></a>核心原理总结</h4><p>ESKF推导的核心是<strong>“化繁为简”</strong>： </p>
<ol>
<li>把“难处理的真实状态”拆成“好算的名义状态 + 小量的误差状态”； </li>
<li>对“非线性的旋转”，用“李代数（线性小向量）+ 指数映射”把非线性误差转成线性； </li>
<li>因为“误差是小量”，把所有非线性运动方程近似成<strong>线性方程</strong>（泰勒一阶展开）； </li>
<li>最终得到“误差如何随时间变化”的线性方程，方便用卡尔曼滤波估计误差，再修正名义状态。 类比：就像用“粗略地图（名义状态）+ 小范围偏差（误差状态）”导航，因为偏差小，所以“偏差的变化”可以用简单的线性规律计算，最后把偏差补到粗略地图上，就能得到精准位置。</li>
</ol>
<h3 id="ESKF预测过程"><a href="#ESKF预测过程" class="headerlink" title="ESKF预测过程"></a>ESKF预测过程</h3><p>预测分为<strong>名义状态预测</strong>和<strong>误差状态预测</strong>：</p>
<ol>
<li><p><strong>名义状态预测</strong>：直接用 IMU 原始数据（角速度 ω~、加速度 a~）积分，得到 “无误差的粗略状态”（这是传统惯性导航的积分过程，不涉及滤波，仅更新 “名义值” 的大趋势）。</p>
</li>
<li><p><strong>误差状态预测</strong>：</p>
<ul>
<li><strong>误差状态先验</strong>：利用线性化的离散方程 $δx_{pred}=Fδx$，即 “当前误差状态乘以雅克比矩阵 F，得到预测时刻的误差状态”（因误差是小量，线性关系成立）。</li>
<li><strong>误差协方差先验</strong>：利用<strong>线性卡尔曼滤波的协方差传播律</strong> $P_{pred}=FPF^⊤+Q$，其中 P 是当前误差协方差，Q 是过程噪声协方差（由各误差项的噪声方差组成）。</li>
</ul>
<script type="math/tex; mode=display">
P_{pred}=FPF^⊤+Q</script><p>ESKF 推导的核心是分而治之：</p>
<p>对 “大状态（名义状态）” 用非线性积分（惯性导航）保证趋势；</p>
<p>对 “小偏差（误差状态）” 用<strong>线性化 + 线性卡尔曼滤波</strong>处理精度；</p>
<p><strong>:exclamation:为什么预测误差协方差:grey_question:</strong></p>
<p>答：在误差状态卡尔曼滤波器（ESKF）中，<strong>预测误差协方差</strong>是为了<strong>跟踪误差的不确定性如何随系统运动和噪声传播</strong>，是卡尔曼滤波 “最优融合预测与观测” 的核心前提。卡尔曼滤波分 “预测（Predict）” 和 “更新（Update）” 两步。</p>
</li>
</ol>
<p><strong>名义状态变量的离散时间运动学方程：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
p(t+\Delta t) &= p(t) + v \Delta t + \frac{1}{2} \bigl(R(\tilde{a} - b_a)\bigr) \Delta t^2 + \frac{1}{2} g \Delta t^2, \\
v(t+\Delta t) &= v(t) + R(\tilde{a} - b_a) \Delta t + g \Delta t, \\
R(t+\Delta t) &= R(t) \exp\bigl((\tilde{\omega} - b_g) \Delta t\bigr), \\
b_g(t+\Delta t) &= b_g(t), \\
b_a(t+\Delta t) &= b_a(t), \\
g(t+\Delta t) &= g(t).
\end{align*}</script><p><strong>误差状态变量的离散时间运动学方程：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
\delta p(t + \Delta t) &= \delta p + \delta v \Delta t, \\
\delta v(t + \Delta t) &= \delta v + \bigl(-R (\tilde{a} - b_a)^\wedge \delta \theta - R \delta b_a + \delta g\bigr) \Delta t - \eta_v, \\
\delta \theta(t + \Delta t) &= Exp \bigl(-(\tilde{\omega} - b_g) \Delta t\bigr) \delta \theta - \delta b_g \Delta t - \eta_\theta, \\
\delta b_g(t + \Delta t) &= \delta b_g + \eta_{bg}, \\
\delta b_a(t + \Delta t) &= \delta b_a + \eta_{ba}, \\
\delta g(t + \Delta t) &= \delta g.
\end{align*}</script><h3 id="ESKF更新过程"><a href="#ESKF更新过程" class="headerlink" title="ESKF更新过程"></a>ESKF更新过程</h3><script type="math/tex; mode=display">
\boldsymbol{K} = \boldsymbol{P}_{\text{pred}} \boldsymbol{H}^\top \left( \boldsymbol{H} \boldsymbol{P}_{\text{pred}} \boldsymbol{H}^\top + \boldsymbol{V} \right)^{-1}</script><script type="math/tex; mode=display">
\delta \boldsymbol{x} = \boldsymbol{K} \left( \boldsymbol{z} - h(\boldsymbol{x}_{\text{pred}}) \right)</script><script type="math/tex; mode=display">
\boldsymbol{x} = \boldsymbol{x}_{\text{pred}} + \delta \boldsymbol{x}</script><script type="math/tex; mode=display">
\boldsymbol{P} = \left( \boldsymbol{I} - \boldsymbol{K} \boldsymbol{H} \right) \boldsymbol{P}_{\text{pred}}</script><h3 id="ESKF的误差状态后续处理"><a href="#ESKF的误差状态后续处理" class="headerlink" title="ESKF的误差状态后续处理"></a>ESKF的误差状态后续处理</h3><p>ESKF（误差状态卡尔曼滤波器）完成 “预测 - 更新” 后，要做两件事：<strong>把误差 “合并” 到名义状态</strong>，再<strong>重置滤波器</strong>，方便下一轮迭代。</p>
<p>名义状态是 “当前认为的大致状态”，误差是 “修正量”。需要把修正量合并到名义状态里，得到更准确的状态：</p>
<ul>
<li>位置、速度、陀螺偏置、加速度计偏置、重力：直接用「名义值 + 误差值」（比如新位置 = 旧名义位置 + 位置误差）。</li>
<li>旋转（特殊情况）：旋转不能直接 “相加”，得用<strong>指数映射</strong>（把旋转误差从 “线性的小量描述” 转换成 “旋转矩阵的形式”），再和旧的旋转矩阵相乘（公式里 Rk+1=RkExp(δθk)，就是旧旋转 “叠加” 误差对应的旋转）。</li>
</ul>
<p>合并完误差后，要重置滤波器，让它能继续处理下一段时间的误差：</p>
<ul>
<li>均值部分：把误差状态 δx 置为 0。因为误差已经 “合并到名义状态里了”，现在误差状态要重新开始跟踪<strong>新的误差</strong>，所以均值归零。</li>
<li>协方差部分：重置后，协方差的 “参考基准” 变了。尤其是旋转，它的  “线性近似空间（切空间）” 的 “零点” 发生了变化，所以数学上要区分 “重置前 和  “重置后的协方差。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> S = <span class="keyword">double</span>&gt;</span><br><span class="line">class ESKF &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 类型定义</span></span><br><span class="line">    <span class="keyword">using</span> SO3 = Sophus::SO3&lt;S&gt;;                     <span class="comment">// 旋转变量类型</span></span><br><span class="line">    <span class="keyword">using</span> VecT = Eigen::Matrix&lt;S, <span class="number">3</span>, <span class="number">1</span>&gt;;            <span class="comment">// 向量类型</span></span><br><span class="line">    <span class="keyword">using</span> Vec18T = Eigen::Matrix&lt;S, <span class="number">18</span>, <span class="number">1</span>&gt;;         <span class="comment">// 18维向量类型</span></span><br><span class="line">    <span class="keyword">using</span> Mat3T = Eigen::Matrix&lt;S, <span class="number">3</span>, <span class="number">3</span>&gt;;           <span class="comment">// 3x3矩阵类型</span></span><br><span class="line">    <span class="keyword">using</span> MotionNoiseT = Eigen::Matrix&lt;S, <span class="number">18</span>, <span class="number">18</span>&gt;;  <span class="comment">// 运动噪声类型</span></span><br><span class="line">    <span class="keyword">using</span> OdomNoiseT = Eigen::Matrix&lt;S, <span class="number">3</span>, <span class="number">3</span>&gt;;      <span class="comment">// 里程计噪声类型</span></span><br><span class="line">    <span class="keyword">using</span> GnssNoiseT = Eigen::Matrix&lt;S, <span class="number">6</span>, <span class="number">6</span>&gt;;      <span class="comment">// GNSS噪声类型</span></span><br><span class="line">    <span class="keyword">using</span> Mat18T = Eigen::Matrix&lt;S, <span class="number">18</span>, <span class="number">18</span>&gt;;        <span class="comment">// 18维方差类型</span></span><br><span class="line">    <span class="keyword">using</span> NavStateT = NavState&lt;S&gt;;                  <span class="comment">// 整体名义状态变量类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Options</span> &#123;</span></span><br><span class="line">        <span class="built_in">Options</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// IMU 测量与零偏参数</span></span><br><span class="line">        <span class="keyword">double</span> imu_dt_ = <span class="number">0.01</span>;  <span class="comment">// IMU测量间隔</span></span><br><span class="line">        <span class="comment">// NOTE IMU噪声项都为离散时间，不需要再乘dt，可以由初始化器指定IMU噪声</span></span><br><span class="line">        <span class="keyword">double</span> gyro_var_ = <span class="number">1e-5</span>;       <span class="comment">// 陀螺测量标准差</span></span><br><span class="line">        <span class="keyword">double</span> acce_var_ = <span class="number">1e-2</span>;       <span class="comment">// 加计测量标准差</span></span><br><span class="line">        <span class="keyword">double</span> bias_gyro_var_ = <span class="number">1e-6</span>;  <span class="comment">// 陀螺零偏游走标准差</span></span><br><span class="line">        <span class="keyword">double</span> bias_acce_var_ = <span class="number">1e-4</span>;  <span class="comment">// 加计零偏游走标准差</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 里程计参数</span></span><br><span class="line">        <span class="keyword">double</span> odom_var_ = <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">double</span> odom_span_ = <span class="number">0.1</span>;        <span class="comment">// 里程计测量间隔</span></span><br><span class="line">        <span class="keyword">double</span> wheel_radius_ = <span class="number">0.155</span>;   <span class="comment">// 轮子半径</span></span><br><span class="line">        <span class="keyword">double</span> circle_pulse_ = <span class="number">1024.0</span>;  <span class="comment">// 编码器每圈脉冲数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// RTK 观测参数</span></span><br><span class="line">        <span class="keyword">double</span> gnss_pos_noise_ = <span class="number">0.1</span>;                   <span class="comment">// GNSS位置噪声</span></span><br><span class="line">        <span class="keyword">double</span> gnss_height_noise_ = <span class="number">0.1</span>;                <span class="comment">// GNSS高度噪声</span></span><br><span class="line">        <span class="keyword">double</span> gnss_ang_noise_ = <span class="number">1.0</span> * math::kDEG2RAD;  <span class="comment">// GNSS旋转噪声</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 其他配置</span></span><br><span class="line">        <span class="keyword">bool</span> update_bias_gyro_ = <span class="literal">true</span>;  <span class="comment">// 是否更新陀螺bias</span></span><br><span class="line">        <span class="keyword">bool</span> update_bias_acce_ = <span class="literal">true</span>;  <span class="comment">// 是否更新加计bias</span></span><br><span class="line">    &#125;;	</span><br><span class="line">	<span class="comment">//.................................	</span></span><br><span class="line">	<span class="comment">/// 成员变量</span></span><br><span class="line">    <span class="keyword">double</span> current_time_ = <span class="number">0.0</span>;  <span class="comment">// 当前时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 成员变量</span></span><br><span class="line">    <span class="keyword">double</span> current_time_ = <span class="number">0.0</span>;  <span class="comment">// 当前时刻的时间戳，初始化为0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 名义状态（系统的主要状态估计值）</span></span><br><span class="line">    VecT p_ = VecT::<span class="built_in">Zero</span>();      <span class="comment">// 位置向量（通常为3维），初始化为零向量</span></span><br><span class="line">    VecT v_ = VecT::<span class="built_in">Zero</span>();      <span class="comment">// 速度向量（通常为3维），初始化为零向量</span></span><br><span class="line">    SO3 R_;                      <span class="comment">// 旋转矩阵（基于特殊正交群SO3表示的姿态），表示当前坐标系的旋转姿态</span></span><br><span class="line">    VecT bg_ = VecT::<span class="built_in">Zero</span>();     <span class="comment">// 陀螺仪零偏向量（用于补偿陀螺仪的系统误差），初始化为零向量</span></span><br><span class="line">    VecT ba_ = VecT::<span class="built_in">Zero</span>();     <span class="comment">// 加速度计零偏向量（用于补偿加速度计的系统误差），初始化为零向量</span></span><br><span class="line">    VecT g_&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-9.8</span>&#125;;         <span class="comment">// 重力加速度向量，初始化为[0, 0, -9.8]（通常假设z轴向下为正方向）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 误差状态（用于卡尔曼滤波等算法中，表示名义状态与真实状态的偏差）</span></span><br><span class="line">    Vec18T dx_ = Vec18T::<span class="built_in">Zero</span>(); <span class="comment">// 18维误差状态向量（通常包含位置、速度、姿态、零偏等的误差），初始化为零向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 协方差阵（描述状态估计的不确定性）</span></span><br><span class="line">    Mat18T cov_ = Mat18T::<span class="built_in">Identity</span>(); <span class="comment">// 18x18的状态协方差矩阵（表示各误差状态之间的相关性和不确定性），初始化为单位矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 噪声阵（描述系统和观测的噪声特性）</span></span><br><span class="line">    MotionNoiseT Q_ = MotionNoiseT::<span class="built_in">Zero</span>(); <span class="comment">// 运动模型的过程噪声协方差矩阵（描述系统运动中的随机噪声），初始化为零矩阵</span></span><br><span class="line">    OdomNoiseT odom_noise_ = OdomNoiseT::<span class="built_in">Zero</span>(); <span class="comment">// 里程计观测的噪声协方差矩阵（描述里程计测量值的不确定性），初始化为零矩阵</span></span><br><span class="line">    GnssNoiseT gnss_noise_ = GnssNoiseT::<span class="built_in">Zero</span>(); <span class="comment">// GNSS（全球导航卫星系统）观测的噪声协方差矩阵（描述GNSS测量值的不确定性），初始化为零矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 标志位</span></span><br><span class="line">    <span class="keyword">bool</span> first_gnss_ = <span class="literal">true</span>;  <span class="comment">// 是否为第一个gnss数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 配置项</span></span><br><span class="line">    Options options_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>名义状态包含位置、速度、旋转、零偏和重力，误差状态对应它们的向量形式。误差状态变量应该为 3 <em>×</em> 6 = 18 维向量，对应的协方差矩阵亦为 18 <em>×</em> 18 维方阵。</p>
<h4 id="预测过程"><a href="#预测过程" class="headerlink" title="预测过程"></a>预测过程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</span><br><span class="line"><span class="keyword">bool</span> ESKF&lt;S&gt;::<span class="built_in">Predict</span>(<span class="keyword">const</span> IMU&amp; imu) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(imu.timestamp_ &gt;= current_time_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> dt = imu.timestamp_ - current_time_;</span><br><span class="line">    <span class="keyword">if</span> (dt &gt; (<span class="number">5</span> * options_.imu_dt_) || dt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 时间间隔不对，可能是第一个IMU数据，没有历史信息</span></span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;skip this imu because dt_ = &quot;</span> &lt;&lt; dt;</span><br><span class="line">        current_time_ = imu.timestamp_;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nominal state 递推</span></span><br><span class="line">    VecT new_p = p_ + v_ * dt + <span class="number">0.5</span> * (R_ * (imu.acce_ - ba_)) * dt * dt + <span class="number">0.5</span> * g_ * dt * dt;</span><br><span class="line">    VecT new_v = v_ + R_ * (imu.acce_ - ba_) * dt + g_ * dt;</span><br><span class="line">    SO3 new_R = R_ * SO3::<span class="built_in">exp</span>((imu.gyro_ - bg_) * dt);</span><br><span class="line"></span><br><span class="line">    R_ = new_R;</span><br><span class="line">    v_ = new_v;</span><br><span class="line">    p_ = new_p;</span><br><span class="line">    <span class="comment">// 其余状态维度不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// error state 递推</span></span><br><span class="line">    <span class="comment">// 计算运动过程雅可比矩阵 F，见(3.47)</span></span><br><span class="line">    <span class="comment">// F实际上是稀疏矩阵，也可以不用矩阵形式进行相乘而是写成散装形式，这里为了教学方便，使用矩阵形式</span></span><br><span class="line">    Mat18T F = Mat18T::<span class="built_in">Identity</span>();                                                 <span class="comment">// 主对角线</span></span><br><span class="line">    F.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = Mat3T::<span class="built_in">Identity</span>() * dt;                         <span class="comment">// p 对 v</span></span><br><span class="line">    F.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">6</span>) = -R_.<span class="built_in">matrix</span>() * SO3::<span class="built_in">hat</span>(imu.acce_ - ba_) * dt;  <span class="comment">// v对theta</span></span><br><span class="line">    F.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">12</span>) = -R_.<span class="built_in">matrix</span>() * dt;                             <span class="comment">// v 对 ba</span></span><br><span class="line">    F.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">15</span>) = Mat3T::<span class="built_in">Identity</span>() * dt;                        <span class="comment">// v 对 g</span></span><br><span class="line">    F.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>) = SO3::<span class="built_in">exp</span>(-(imu.gyro_ - bg_) * dt).<span class="built_in">matrix</span>();     <span class="comment">// theta 对 theta</span></span><br><span class="line">    F.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>) = -Mat3T::<span class="built_in">Identity</span>() * dt;                        <span class="comment">// theta 对 bg</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mean and cov prediction</span></span><br><span class="line">    dx_ = F * dx_;  <span class="comment">// 这行其实没必要算，dx_在重置之后应该为零，因此这步可以跳过，但F需要参与Cov部分计算，所以保留</span></span><br><span class="line">    cov_ = F * cov_.<span class="built_in">eval</span>() * F.<span class="built_in">transpose</span>() + Q_;</span><br><span class="line">    current_time_ = imu.timestamp_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{align*}
p(t+\Delta t) &= p(t) + v \Delta t + \frac{1}{2} \bigl(R(\tilde{a} - b_a)\bigr) \Delta t^2 + \frac{1}{2} g \Delta t^2, \\
v(t+\Delta t) &= v(t) + R(\tilde{a} - b_a) \Delta t + g \Delta t, \\
R(t+\Delta t) &= R(t) \exp\bigl((\tilde{\omega} - b_g) \Delta t\bigr) 
\end{align*}</script><script type="math/tex; mode=display">
δx_{pred}=Fδx</script><script type="math/tex; mode=display">
P_{pred}=FPF^⊤+Q</script><h4 id="RTK预测"><a href="#RTK预测" class="headerlink" title="RTK预测"></a>RTK预测</h4><p>RTK 既能观测位置，也能观测角度（单天线不可）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ESKF&lt;S&gt;::<span class="built_in">ObserveGps</span>(<span class="keyword">const</span> GNSS&amp; gnss) &#123;</span><br><span class="line">    <span class="comment">/// GNSS 观测的修正</span></span><br><span class="line">    <span class="comment">// 断言：确保GNSS数据的时间戳不早于当前滤波器的时间，避免处理过期数据</span></span><br><span class="line">    <span class="comment">// assert 解读 https://blog.csdn.net/weixin_45031801/article/details/136882008</span></span><br><span class="line">    <span class="built_in">assert</span>(gnss.unix_time_ &gt;= current_time_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是第一次接收GNSS数据</span></span><br><span class="line">    <span class="keyword">if</span> (first_gnss_) &#123;</span><br><span class="line">        <span class="comment">// 用GNSS的UTM坐标姿态初始化滤波器的旋转矩阵（R_）</span></span><br><span class="line">        R_ = gnss.utm_pose_.<span class="built_in">so3</span>();</span><br><span class="line">        <span class="comment">// 用GNSS的UTM坐标位置初始化滤波器的位置（p_）</span></span><br><span class="line">        p_ = gnss.utm_pose_.<span class="built_in">translation</span>();</span><br><span class="line">        <span class="comment">// 标记为非首次接收GNSS数据</span></span><br><span class="line">        first_gnss_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 更新滤波器当前时间为GNSS数据的时间戳</span></span><br><span class="line">        current_time_ = gnss.unix_time_;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言：确保GNSS的航向信息（heading）有效，否则后续姿态修正会出错</span></span><br><span class="line">    <span class="built_in">assert</span>(gnss.heading_valid_);</span><br><span class="line">    <span class="comment">// 调用SE3观测处理函数，用GNSS的UTM位姿（包含位置和姿态）修正滤波器状态</span></span><br><span class="line">    <span class="comment">// 传入GNSS的位置噪声和角度噪声参数（从配置中获取）</span></span><br><span class="line">    <span class="built_in">ObserveSE3</span>(gnss.utm_pose_, options_.gnss_pos_noise_, options_.gnss_ang_noise_);</span><br><span class="line">    <span class="comment">// 更新滤波器当前时间为GNSS数据的时间戳</span></span><br><span class="line">    current_time_ = gnss.unix_time_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SE3观测处理函数，用GNSS的UTM位姿修正滤波器状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</span><br><span class="line"><span class="keyword">bool</span> ESKF&lt;S&gt;::<span class="built_in">ObserveSE3</span>(<span class="keyword">const</span> SE3&amp; pose, <span class="keyword">double</span> trans_noise, <span class="keyword">double</span> ang_noise) &#123;</span><br><span class="line">    <span class="comment">/// 既有旋转，也有平移</span></span><br><span class="line">    <span class="comment">/// 观测状态变量中的p, R，H为6x18，其余为零</span></span><br><span class="line">    <span class="comment">// 定义观测矩阵H（6行18列），初始化为全零</span></span><br><span class="line">    <span class="comment">// H的作用：描述&quot;误差状态&quot;与&quot;观测残差&quot;之间的线性关系</span></span><br><span class="line">    Eigen::Matrix&lt;S, <span class="number">6</span>, <span class="number">18</span>&gt; H = Eigen::Matrix&lt;S, <span class="number">6</span>, <span class="number">18</span>&gt;::<span class="built_in">Zero</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// H的前3行对应&quot;平移观测&quot;，与误差状态中的&quot;位置误差&quot;（前3维）直接相关，故用3x3单位矩阵</span></span><br><span class="line">    H.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = Mat3T::<span class="built_in">Identity</span>();  <span class="comment">// P部分（位置误差对应平移观测）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// H的后3行对应&quot;旋转观测&quot;，与误差状态中的&quot;旋转误差&quot;（第6-8维，通常旋转误差在误差状态的第6-8位）直接相关，故用3x3单位矩阵</span></span><br><span class="line">    H.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">6</span>) = Mat3T::<span class="built_in">Identity</span>();  <span class="comment">// R部分（旋转误差对应旋转观测）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卡尔曼增益和更新过程</span></span><br><span class="line">    <span class="comment">// 定义观测噪声向量：前3个是平移噪声，后3个是旋转噪声</span></span><br><span class="line">    Vec6d noise_vec;</span><br><span class="line">    noise_vec &lt;&lt; trans_noise, trans_noise, trans_noise, ang_noise, ang_noise, ang_noise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造观测噪声协方差矩阵V（6x6对角矩阵），对角元素为噪声的平方（表示观测不确定性）</span></span><br><span class="line">    Mat6d V = noise_vec.<span class="built_in">asDiagonal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算卡尔曼增益K（18x6矩阵）</span></span><br><span class="line">    <span class="comment">// 公式：K = P * H^T * (H * P * H^T + V)^(-1)</span></span><br><span class="line">    <span class="comment">// 其中：P是当前误差状态的协方差（cov_），H^T是观测矩阵的转置，分母是观测残差的协方差</span></span><br><span class="line">    Eigen::Matrix&lt;S, <span class="number">18</span>, <span class="number">6</span>&gt; K = cov_ * H.<span class="built_in">transpose</span>() * (H * cov_ * H.<span class="built_in">transpose</span>() + V).<span class="built_in">inverse</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算观测残差（创新项innov）：观测值与预测值的差异</span></span><br><span class="line">    Vec6d innov = Vec6d::<span class="built_in">Zero</span>();</span><br><span class="line">    <span class="comment">// 平移残差：观测位置 - 当前滤波器估计的位置（p_）</span></span><br><span class="line">    innov.<span class="keyword">template</span> head&lt;<span class="number">3</span>&gt;() = (pose.<span class="built_in">translation</span>() - p_);          </span><br><span class="line">    <span class="comment">// 旋转残差：将&quot;当前旋转R_到观测旋转pose.so3()&quot;的相对旋转转换为李代数向量</span></span><br><span class="line">    <span class="comment">// 步骤：1. 计算R_.inverse() * pose.so3()（得到从当前旋转到观测旋转的相对旋转）</span></span><br><span class="line">    <span class="comment">//      2. 用log()（李群到李代数的对数映射）将旋转矩阵转换为3维向量（方便计算残差）</span></span><br><span class="line">    innov.<span class="keyword">template</span> tail&lt;<span class="number">3</span>&gt;() = (R_.<span class="built_in">inverse</span>() * pose.<span class="built_in">so3</span>()).<span class="built_in">log</span>();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新误差状态和协方差</span></span><br><span class="line">    <span class="comment">// 用卡尔曼增益K和残差innov计算新的误差状态dx_</span></span><br><span class="line">    dx_ = K * innov;</span><br><span class="line">    <span class="comment">// 更新协方差矩阵：P_new = (I - K*H) * P_old（卡尔曼滤波协方差更新公式）</span></span><br><span class="line">    cov_ = (Mat18T::<span class="built_in">Identity</span>() - K * H) * cov_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将误差状态融合到名义状态中，并重置误差状态（ESKF的核心操作）</span></span><br><span class="line">    <span class="built_in">UpdateAndReset</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将误差状态融合到名义状态中，并重置误差状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 更新名义状态变量，重置error state</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p_ += dx_.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    v_ += dx_.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    R_ = R_ * SO3::<span class="built_in">exp</span>(dx_.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options_.update_bias_gyro_) &#123;</span><br><span class="line">        bg_ += dx_.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options_.update_bias_acce_) &#123;</span><br><span class="line">        ba_ += dx_.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_ += dx_.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ProjectCov</span>();</span><br><span class="line">    dx_.<span class="built_in">setZero</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静止初始化"><a href="#静止初始化" class="headerlink" title="静止初始化"></a>静止初始化</h4><p>在静止时间内，由于物体本身没有任何运动，可以简单地认为 IMU 的陀螺仪只测到零偏，而加速度计则测到零偏与重力之和。</p>
<ol>
<li><strong>让车辆静止</strong>：程序设 10 秒，用轮速判断（两轮速度都低于阈值就算静止；没轮速时，直接假设车辆静止）。</li>
<li><strong>统计传感器平均读数</strong>：记录这 10 秒内陀螺仪、加速度计的读数平均值，分别叫dˉgyr、dˉacc。</li>
<li><strong>确定陀螺仪零偏</strong>：车辆没转动，所以陀螺仪的 “静止偏差（零偏）bg” 就等于陀螺仪的平均读数dˉgyr。</li>
<li><strong>确定重力方向</strong>：加速度计的测量公式里，车辆静止时实际加速度为 0、旋转近似为 “无旋转”（旋转矩阵R看成单位阵），此时加速度计测的是 “加速度计偏差ba-重力g”。于是，取 “加速度计平均读数的反方向”、大小 9.8 的向量，作为重力g的方向。</li>
<li><strong>去除重力重算加速度计平均</strong>：把加速度计读数里的重力成分去掉，重新计算加速度计的平均值dˉacc。</li>
<li><strong>确定加速度计零偏</strong>：加速度计的 “静止偏差（零偏）ba” 等于重新计算后的加速度计平均值dˉacc。</li>
<li><strong>估计测量方差</strong>：假设零偏不变，算出陀螺仪、加速度计的测量方差，这些方差能作为 ESKF（误差状态卡尔曼滤波器）的噪声参数，让后续滤波更准确。</li>
</ol>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>ERROR：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/run_eskf_gins: error <span class="keyword">while</span> loading shared libraries: libpango_windowing.so.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250909160448713.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250909160448713.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250909160448713"></p>
<p><strong>基础融合：IMU+GNSS 的优势</strong><br>IMU（惯性测量单元）的优点是 “更新快”（高频定位），但单独用会慢慢飘（误差累积）；GNSS（卫星定位)的优点是 “准且稳”，但更新慢。ESKF 把两者融合后，既能输出高频定位信号，又能让精度和 GNSS 差不多，兼顾了 “快” 和 “稳”。</p>
<p><strong>不止 IMU+GNSS，其他传感器也能融</strong><br>比如后续要加的激光雷达、摄像头，只要能把它们的观测数据 “转化成 ESKF 能处理的线性形式”（专业叫 “线性化”），就能融入 ESKF。比如激光先算出自家的位姿，再给  ESKF；摄像头先算特征点的位置误差，再给 ESKF—— 核心理论都一样，只是不同传感器的 “噪声大小 / 规律”  不一样（比如激光噪声可能比摄像头小）。</p>
<p><strong>两种融合方式：松耦合 vs 紧耦合</strong></p>
<ul>
<li><strong>松耦合（简单直接）</strong>：融的是 “传感器先算好的位姿结果”（比如激光先自己算出车辆位姿，再把这个位姿当 “观测值” 给 ESKF），不用管传感器原始数据。</li>
<li><strong>紧耦合（更精细）</strong>：不融 “算好的位姿”，直接融 “传感器的原始误差”（比如激光点云跟地图匹配的偏差、摄像头特征点投到图像上的位置误差），更直接利用原始数据，精度通常更高。</li>
</ul>
<p>对比下 ESKF 和图优化在处理 “运动状态”（比如位置、速度）和 “传感器观测数据”（比如 GNSS、轮速）时的思路：两者很多核心逻辑是相通的，但具体动手做的</p>
<p>方式不一样。</p>
<p>这里要重点说 ESKF 的一个关键操作：它的 “更新过程” 本质是在做 “边缘化”。简单理解就是，ESKF 会把过去所有传感器的观测信息（比如之前的  GNSS 数据、轮</p>
<p>速数据）“打包压缩”，变成一份 “参考依据”（专业里叫 “<strong>先验</strong>”），直接用在当前时刻的计算中。而且 ESKF算出的当前状态均值 x（比如当前位置、速度的估计值）</p>
<p>和方差 P（这个估计值的不确定性），不只是用在当下，还会当成 “提前准备好的参考” 传给下一个时刻。有了这份 “参考”，滤波器每次迭代更新时就不会  “没头没</p>
<p>脑乱算”，而是有之前的信息打底，迭代过程会更稳定（不会忽快忽慢、误差突然跳变），这就是 “平滑整个滤波器迭代过程” 的意思。</p>
<p>但图优化不一样，它通常没有这种 “对所有状态变量的提前参考（先验）”。所以对图优化来说，怎么处理这份 “提前参考”（比如要不要加、加多少权重），就成了</p>
<p>算法能不能做好的关键问题。</p>
<h3 id="速度观测量"><a href="#速度观测量" class="headerlink" title="速度观测量"></a>速度观测量</h3><p>在GINS系统中，如果长时间缺少RTK观测数据，ESKF就变为纯靠IMU积分的递推模式。该模式下位移将很快发散。位移的发散主要原因是缺少速度观测。有没</p>
<p>有什么方法可以限制速度的发散呢？最常见的方法是融入车辆的速度传感器。速度测量值主要来自车辆的电机转速或者轮式编码器。大部分轮式机器人会携带一个</p>
<p>编码器以测定自身速度，进而推断自身的局部运动情况。有时候我们也可以使用电机转速、油门等底层测量值来测定机器人的速度值。这些速度观测与IMU结</p>
<p>合，可以形成局部的<strong>航迹推算</strong>（Dead Reckoning）。</p>
<p>代码实现思路：</p>
<p>代码实现思路</p>
<ol>
<li><strong>读取轮速数据</strong>：从编码器或电机转速计获取vwheel（注意坐标系转换，确保与 ESKF 中的速度坐标系一致）。</li>
<li><strong>计算速度残差</strong>：$residual=v_{wheel}−\tilde v$（$\tilde v$是 ESKF 预测的名义速度）。</li>
<li><strong>构造H矩阵</strong>：按上述结构，仅速度误差对应位置设为单位矩阵。</li>
<li><strong>更新 ESKF 状态</strong>：调用卡尔曼增益计算、误差状态修正、协方差更新的函数，完成速度观测的融合。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</span><br><span class="line"><span class="keyword">bool</span> ESKF&lt;S&gt;::<span class="built_in">ObserveWheelSpeed</span>(<span class="keyword">const</span> Odom&amp; odom) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(odom.timestamp_ &gt;= current_time_);</span><br><span class="line">    <span class="comment">// odom 修正以及雅可比</span></span><br><span class="line">    <span class="comment">// 使用三维的轮速观测，H为3x18，大部分为零</span></span><br><span class="line">    Eigen::Matrix&lt;S, <span class="number">3</span>, <span class="number">18</span>&gt; H = Eigen::Matrix&lt;S, <span class="number">3</span>, <span class="number">18</span>&gt;::<span class="built_in">Zero</span>();</span><br><span class="line">    H.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = Mat3T::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卡尔曼增益</span></span><br><span class="line">    Eigen::Matrix&lt;S, <span class="number">18</span>, <span class="number">3</span>&gt; K = cov_ * H.<span class="built_in">transpose</span>() * (H * cov_ * H.<span class="built_in">transpose</span>() + odom_noise_).<span class="built_in">inverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// velocity obs</span></span><br><span class="line">    <span class="keyword">double</span> velo_l = options_.wheel_radius_ * odom.left_pulse_ / options_.circle_pulse_ * <span class="number">2</span> * M_PI / options_.odom_span_;</span><br><span class="line">    <span class="keyword">double</span> velo_r =</span><br><span class="line">        options_.wheel_radius_ * odom.right_pulse_ / options_.circle_pulse_ * <span class="number">2</span> * M_PI / options_.odom_span_;</span><br><span class="line">    <span class="keyword">double</span> average_vel = <span class="number">0.5</span> * (velo_l + velo_r);</span><br><span class="line"></span><br><span class="line">    <span class="function">VecT <span class="title">vel_odom</span><span class="params">(average_vel, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    VecT vel_world = R_ * vel_odom;</span><br><span class="line">	<span class="comment">// 更新速度残差</span></span><br><span class="line">    dx_ = K * (vel_world - v_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update cov 更新协方差矩阵</span></span><br><span class="line">    cov_ = (Mat18T::<span class="built_in">Identity</span>() - K * H) * cov_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UpdateAndReset</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入轮速里程计后的轨迹图，绿色部分为与上区别，比上面更平滑了。</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250909163901262.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250909163901262.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250909163901262"></p>
<h2 id="预积分学"><a href="#预积分学" class="headerlink" title="预积分学"></a>预积分学</h2><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/4_1预计分学.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/4_1预计分学.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>之前的 ESKF（误差状态卡尔曼滤波）处理 IMU 数据时，是 “一次性” 利用：在两个 GNSS（卫星定位）观测的间隔里，把 IMU  数据积分到当前的状态估计上，再</p>
<p>用 GNSS 更新。但这种做法有局限 —— 如果状态估计变了，IMU 数据没法重复用。可从物理角度，IMU  反映的是 “两个时刻间车辆的角度、速度变化量”，理论上</p>
<p>应该能和 “当时的状态估计” 解绑，重复利用。</p>
<p>这就需要 “预积分”：它能把<strong>一段时间内的 IMU 测量数据先 “攒起来”，生成一个 “预积分测量值”</strong>，而且这个测量值和状态变量无关。打个比方，ESKF 是 “一口</p>
<p>一口吃菜”，预积分是 “先把菜从锅里夹到碗里，再一口气吃碗里的菜”（碗的大小、夹菜次数更灵活）。现在像  LIO（激光惯性里程计）、VIO（视觉惯性里程计）</p>
<p>这类和 IMU 深度结合的系统，预积分已经成了标准方法，只是原理比传统 ESKF 的预测过程更复杂。</p>
<p>IMU频率高100～500HZ，预积分缩短采样频率。</p>
<p>预积分模型可以很容易地与其他图优化模型进行融合，在同一个问题中进行优化。也可以很方便地设置积分时间、优化帧数等参数，相比于滤波器方案更加自由。</p>
<script type="math/tex; mode=display">
R_j = R_i \prod_{k=i}^{j-1} \bigl(Exp\bigl((\tilde{\omega}_k - b_{g,k} - \eta_{gd,k}) \Delta t\bigr)\bigr)</script><script type="math/tex; mode=display">
v_j = v_i + g \Delta t_{ij} + \sum_{k=i}^{j-1} R_k (\tilde{a}_k - b_{a,k} - \eta_{ad,k}) \Delta t</script><script type="math/tex; mode=display">
p_j = p_i + \sum_{k=i}^{j-1} v_k \Delta t + \frac{1}{2} \sum_{k=i}^{j-1} g \Delta t^2 + \frac{1}{2} \sum_{k=i}^{j-1} R_k (\tilde{a}_k - b_{a,k} - \eta_{ad,k}) \Delta t^2</script><p><strong>推导的关系：“相对运动” 与 “IMU 测量 + 零偏” 的数学关联</strong></p>
<p>预积分推导的是 <strong>“关键帧 i 到关键帧 j 的相对运动”</strong>（旋转差ΔRij、速度差Δvij、位移差Δpij）和<strong>“IMU 原始测量（角速度ω~、加速度a~）+ 传感器零偏（陀螺零偏bg、加速度零偏ba）”</strong> 之间的关系。</p>
<p>具体来说，通过对 IMU 的运动学模型（角速度→旋转、加速度→速度 / 位移）进行<strong>积分和线性化</strong>，把 “i 到 j 时刻的 IMU 测量累积” 转化为 “与 i 时刻状态无关的相对量”。例如：</p>
<ul>
<li>旋转差$\Delta \boldsymbol{R}_{ij}$：由角速度测量扣除陀螺零偏后，通过指数映射累积得到；</li>
<li>速度差$\Delta \boldsymbol{v}_{ij}$：由加速度测量扣除加速度零偏、重力后，通过旋转矩阵变换并积分得到；</li>
<li>位移差$\Delta \boldsymbol{p}_{ij}$：由速度差和加速度的二次积分得到。</li>
</ul>
<h3 id="测量模型"><a href="#测量模型" class="headerlink" title="测量模型"></a>测量模型</h3><p>从离散时间点$i$到$j$这段时间里，把 IMU 收集的所有数据 “攒起来” 处理，这个过程能持续好几秒，攒出来的结果就叫预积分。不过，如果用的运动学模型不同，预</p>
<p>积分的形式也会不一样。直接积分 IMU 数据有个缺点：积分过程和 “状态量”（比如某时刻的位置、速度）绑得太死。要是优化了$i$时刻的状态，$i-1$、直到$j−1$</p>
<p>时刻的状态都得跟着变，积分就得重新算，特别麻烦。所以得改造一下，尽量把 IMU 读数和状态量分开，于是定义了<strong>相对运动量</strong>。</p>
<p>使用<strong>相对量</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta R_{ij} &= \prod_{k=i}^{j-1} \underbrace{Exp\left( (\tilde{\omega}_k - b_{g,k} - \eta_{gd,k}) \Delta t \right)}_{\text{利用BCH:} \approx Exp((\tilde{\omega}_k - b_{g,i}) \Delta t) Exp(-J_{r,k} \eta_{gd,k} \Delta t)} , \\
&\approx \prod_{k=i}^{j-1} \left[ Exp\left( (\tilde{\omega}_k - b_{g,i}) \Delta t \right) Exp\left( -J_{r,k} \eta_{gd,k} \Delta t \right) \right].
\end{align*}</script><p>旋转、速度、位移如下:</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta \boldsymbol{R}_{ij} &\doteq \boldsymbol{R}_i^\top \boldsymbol{R}_j = \prod_{k=i}^{j-1} Exp\left( (\tilde{\boldsymbol{\omega}}_k - \boldsymbol{b}_{g,k} - \boldsymbol{\eta}_{gd,k}) \Delta t \right), \\
\Delta \boldsymbol{v}_{ij} &\doteq \boldsymbol{R}_i^\top \left( \boldsymbol{v}_j - \boldsymbol{v}_i - \boldsymbol{g} \Delta t_{ij} \right) = \sum_{k=i}^{j-1} \Delta \boldsymbol{R}_{ik} (\tilde{\boldsymbol{a}}_k - \boldsymbol{b}_{a,k} - \boldsymbol{\eta}_{ad,k}) \Delta t, \\
\Delta \boldsymbol{p}_{ij} &\doteq \boldsymbol{R}_i^\top \left( \boldsymbol{p}_j - \boldsymbol{p}_i - \boldsymbol{v}_i \Delta t_{ij} - \frac{1}{2} \sum_{k=i}^{j-1} \boldsymbol{g} \Delta t^2 \right) \\
&= \sum_{k=i}^{j-1} \left[ \Delta \boldsymbol{v}_{ik} \Delta t + \frac{1}{2} \Delta \boldsymbol{R}_{ik} (\tilde{\boldsymbol{a}}_k - \boldsymbol{b}_{a,k} - \boldsymbol{\eta}_{ad,k}) \Delta t^2 \right].
\end{align*}</script><p>可以转化为</p>
<script type="math/tex; mode=display">
\begin{align*}
\Delta \tilde{R}_{ij} &= \boldsymbol{R}_i^\top \boldsymbol{R}_j Exp(\delta \phi_{ij}), \\
\Delta \tilde{v}_{ij} &= \boldsymbol{R}_i^\top \left( \boldsymbol{v}_j - \boldsymbol{v}_i - \boldsymbol{g} \Delta t_{ij} \right) + \delta \boldsymbol{v}_{ij}, \\
\Delta \tilde{p}_{ij} &= \boldsymbol{R}_i^\top \left( \boldsymbol{p}_j - \boldsymbol{p}_i - \boldsymbol{v}_i \Delta t_{ij} - \frac{1}{2} \boldsymbol{g} \Delta t_{ij}^2 \right) + \delta \boldsymbol{p}_{ij}.
\end{align*}</script><p>左侧变量的定义方式非常适合程序实现。$\Delta \tilde{R}_{ik}$可以通过 IMU 读数得到，$\Delta \tilde{v}_{ik}$可以由 <em>k</em>时刻 IMU 读数和 $\Delta \tilde{R}_{ik}$算得，而 又$\Delta \tilde{p}_{ik}$可以通过前两者计算结果得到。另</p>
<p>一方面，如果知道了 <em>k</em> 时刻的预积分观测量，又很容易根据 $k + 1$时刻传感器读数，计算出$k + 1$ 时刻的预积分观测量。这是由观测的累加定义方式决定的。</p>
<p>其中$Exp(\delta \phi_{ij})、\delta \boldsymbol{v}_{ij}、\delta \boldsymbol{p}_{ij}$为噪声，下面讨论下其噪声模型。</p>
<h3 id="噪声模型"><a href="#噪声模型" class="headerlink" title="噪声模型"></a>噪声模型</h3><h3 id="零偏更新"><a href="#零偏更新" class="headerlink" title="零偏更新"></a>零偏更新</h3><h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><p>预积分的使用围绕 <strong>“预计算 - 构建约束 - 修正零偏”</strong> 展开：</p>
<h4 id="1-预计算"><a href="#1-预计算" class="headerlink" title="1. 预计算"></a>1. 预计算</h4><p>在两个关键帧（如相机 / 激光的关键帧）之间，持续采集 IMU 数据，按预积分公式累积计算$\Delta \boldsymbol{R}_{ij} 、\Delta \boldsymbol{v}_{ij}、\Delta \boldsymbol{p}_{ij}$，并记录积分过程中的<strong>噪声</strong>和<strong>雅克比矩阵</strong>（用于后续优化）。</p>
<h4 id="2-构建优化约束"><a href="#2-构建优化约束" class="headerlink" title="2. 构建优化约束"></a>2. 构建优化约束</h4><p>在图优化（或滤波）中，预积分量作为 <strong>“相对运动约束”</strong>，把不同关键帧的状态（如$i$帧的$R_i,v_i,p_i$和$j$帧的$R_j,v_j,p_j$​）连接起来。例如：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R_j &= R_i \cdot \Delta R_{ij}, \\
v_j &= v_i + \Delta v_{ij}, \\
p_j &= p_i + \Delta p_{ij}
\end{aligned}</script><p>这些约束会被转化为 “优化的代价函数”，让算法在调整关键帧状态时，必须满足 IMU 预积分的相对运动关系。</p>
<h4 id="3-修正零偏"><a href="#3-修正零偏" class="headerlink" title="3. 修正零偏"></a>3. 修正零偏</h4><p>IMU 的零偏（bg,ba）会随时间漂移，若零偏变化，理论上预积分量需要重算。但预积分通过 <strong>“零偏修正公式”</strong>，直接调整已有的预积分量（不用重积分 IMU），就</p>
<p>能适配零偏的变化。例如，陀螺零偏变化δbg时，旋转差ΔRij可通过 “指数映射修正项” 调整，避免重复积分。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对比项</th>
<th style="text-align:center">ESKF（误差状态卡尔曼滤波）</th>
<th style="text-align:center">基于预积分的图优化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">处理逻辑</td>
<td style="text-align:center">逐帧递推更新（局部）</td>
<td style="text-align:center">全局批处理优化（多帧联合）</td>
</tr>
<tr>
<td style="text-align:center">误差积累</td>
<td style="text-align:center">易逐帧累积</td>
<td style="text-align:center">可全局消除累积误差（如回环）</td>
</tr>
<tr>
<td style="text-align:center">实时性</td>
<td style="text-align:center">高（逐帧计算量固定）</td>
<td style="text-align:center">中（计算量随关键帧增加上升）</td>
</tr>
<tr>
<td style="text-align:center">鲁棒性</td>
<td style="text-align:center">对异常敏感</td>
<td style="text-align:center">抗干扰强（多约束 / 核函数抑制）</td>
</tr>
<tr>
<td style="text-align:center">传感器扩展性</td>
<td style="text-align:center">弱（添加新传感器需重推导）</td>
<td style="text-align:center">强（易扩展多传感器约束）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据处理更灵活</strong></p>
<p>图优化可以 <strong>“攒” 一段时间的 IMU 数据 </strong>（；而 ESKF默认只能 “单次处理单个时刻的 IMU 数据”，灵活性差。</p>
<p><strong>靠 “多因子配合” 约束状态</strong></p>
<p>预积分是个 “灵活的优化单元（预积分因子）”，能关联位姿、速度、IMU 偏差等多个状态，但自身不稳定，得和<strong>其他因子配合</strong>：</p>
<ul>
<li>GNSS 因子：限制 “位姿的变化幅度”；</li>
<li>Odom 因子：限制 “速度的变化幅度”；</li>
<li>零偏因子：限制 “IMU 偏差的变化量”。</li>
</ul>
<p><strong>先验因子 让结果更平滑</strong></p>
<p>有个 “先验因子” 能让估计结果更平稳，但严格来说需要复杂处理，这里为了简化用了 “固定参数”。（第 8 章会详细讲它的实现，你可以试试去掉这个因子，看轨迹会不会变得不稳定。）</p>
<p><strong>算力需求高，但实时可用</strong></p>
<p>图优化的计算量比滤波器（如 ESKF）大，更费时间；但现在智能汽车的算力提升了，<strong>实时场景下也能顺畅运行</strong>。</p>
<h2 id="基础点云处理"><a href="#基础点云处理" class="headerlink" title="基础点云处理"></a>基础点云处理</h2><p>查看命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl_viewer ...pcd</span><br></pre></td></tr></table></figure>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250910111913674.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250910111913674.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250910111913674" style="zoom:50%;" /></p>
<p>代码查看</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PointType = pcl::PointXYZI;</span><br><span class="line"><span class="keyword">using</span> PointCloudType = pcl::PointCloud&lt;PointType&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_string</span>(pcd_path, <span class="string">&quot;/home/ychooo/ROS_WS/slam_in_autonomous_driving/data/ch5/map_example.pcd&quot;</span>, <span class="string">&quot;点云文件路径&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 本程序可用于显示单个点云，演示PCL的基本用法</span></span><br><span class="line"><span class="comment">/// 实际上就是调用了pcl的可视化库，类似于pcl_viewer</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    FLAGS_stderrthreshold = google::INFO;</span><br><span class="line">    FLAGS_colorlogtostderr = <span class="literal">true</span>;</span><br><span class="line">    google::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FLAGS_pcd_path.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;pcd path is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取点云</span></span><br><span class="line">    <span class="function">PointCloudType::Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> PointCloudType)</span></span>;</span><br><span class="line">    pcl::io::<span class="built_in">loadPCDFile</span>(FLAGS_pcd_path, *cloud);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cloud-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;cannot load cloud file&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;cloud points: &quot;</span> &lt;&lt; cloud-&gt;<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// visualize</span></span><br><span class="line">    pcl::<span class="function">visualization::PCLVisualizer <span class="title">viewer</span><span class="params">(<span class="string">&quot;cloud viewer&quot;</span>)</span></span>;</span><br><span class="line">    pcl::<span class="function">visualization::PointCloudColorHandlerGenericField&lt;PointType&gt; <span class="title">handle</span><span class="params">(cloud, <span class="string">&quot;z&quot;</span>)</span></span>;  <span class="comment">// 使用高度来着色</span></span><br><span class="line">    viewer.addPointCloud&lt;PointType&gt;(cloud, handle);</span><br><span class="line">    viewer.<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250910145105926.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250910145105926.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250910145105926" style="zoom: 33%;" /></p>
<p>将点云转换为俯视图像</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入gflags库，用于解析命令行参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入glog库，用于日志输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入PCL库的PCD文件读写模块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入PCL库的点云容器类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入PCL库的点类型定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入OpenCV的核心模块（基础数据结构等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// 引入OpenCV的高层GUI模块（图像读写、显示等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义点类型为带强度信息的XYZI点（x,y,z坐标+强度值）</span></span><br><span class="line"><span class="keyword">using</span> PointType = pcl::PointXYZI;</span><br><span class="line"><span class="comment">// 定义点云类型为上述PointType的点云</span></span><br><span class="line"><span class="keyword">using</span> PointCloudType = pcl::PointCloud&lt;PointType&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命令行参数：点云文件路径，默认值为&quot;./data/ch5/map_example.pcd&quot;</span></span><br><span class="line"><span class="built_in">DEFINE_string</span>(pcd_path, <span class="string">&quot;./data/ch5/map_example.pcd&quot;</span>, <span class="string">&quot;点云文件路径&quot;</span>);</span><br><span class="line"><span class="comment">// 定义命令行参数：俯视图分辨率（单位：米/像素），默认0.1米/像素</span></span><br><span class="line"><span class="built_in">DEFINE_double</span>(image_resolution, <span class="number">0.1</span>, <span class="string">&quot;俯视图分辨率&quot;</span>);</span><br><span class="line"><span class="comment">// 定义命令行参数：俯视图包含的点云最低高度（z坐标下限），默认0.2米</span></span><br><span class="line"><span class="built_in">DEFINE_double</span>(min_z, <span class="number">0.2</span>, <span class="string">&quot;俯视图最低高度&quot;</span>);</span><br><span class="line"><span class="comment">// 定义命令行参数：俯视图包含的点云最高高度（z坐标上限），默认2.5米</span></span><br><span class="line"><span class="built_in">DEFINE_double</span>(max_z, <span class="number">2.5</span>, <span class="string">&quot;俯视图最高高度&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 函数功能：将点云转换为俯视图像（BEV，Bird&#x27;s Eye View）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateBEVImage</span><span class="params">(PointCloudType::Ptr cloud)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算点云在x方向的最小和最大坐标（通过自定义比较器比较x值）</span></span><br><span class="line">    <span class="keyword">auto</span> minmax_x = std::<span class="built_in">minmax_element</span>(cloud-&gt;points.<span class="built_in">begin</span>(), cloud-&gt;points.<span class="built_in">end</span>(),</span><br><span class="line">                                        [](<span class="keyword">const</span> PointType&amp; p1, <span class="keyword">const</span> PointType&amp; p2) &#123; <span class="keyword">return</span> p1.x &lt; p2.x; &#125;);</span><br><span class="line">    <span class="comment">// 计算点云在y方向的最小和最大坐标（通过自定义比较器比较y值）</span></span><br><span class="line">    <span class="keyword">auto</span> minmax_y = std::<span class="built_in">minmax_element</span>(cloud-&gt;points.<span class="built_in">begin</span>(), cloud-&gt;points.<span class="built_in">end</span>(),</span><br><span class="line">                                        [](<span class="keyword">const</span> PointType&amp; p1, <span class="keyword">const</span> PointType&amp; p2) &#123; <span class="keyword">return</span> p1.y &lt; p2.y; &#125;);</span><br><span class="line">    <span class="comment">// 提取x方向最小值</span></span><br><span class="line">    <span class="keyword">double</span> min_x = minmax_x.first-&gt;x;</span><br><span class="line">    <span class="comment">// 提取x方向最大值</span></span><br><span class="line">    <span class="keyword">double</span> max_x = minmax_x.second-&gt;x;</span><br><span class="line">    <span class="comment">// 提取y方向最小值</span></span><br><span class="line">    <span class="keyword">double</span> min_y = minmax_y.first-&gt;y;</span><br><span class="line">    <span class="comment">// 提取y方向最大值</span></span><br><span class="line">    <span class="keyword">double</span> max_y = minmax_y.second-&gt;y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算分辨率的倒数（用于将米转换为像素数）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> inv_r = <span class="number">1.0</span> / FLAGS_image_resolution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算图像的行数（y方向像素数）= (y方向范围) * 分辨率倒数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_rows = <span class="built_in"><span class="keyword">int</span></span>((max_y - min_y) * inv_r);</span><br><span class="line">    <span class="comment">// 计算图像的列数（x方向像素数）= (x方向范围) * 分辨率倒数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_cols = <span class="built_in"><span class="keyword">int</span></span>((max_x - min_x) * inv_r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算点云x方向的中心坐标</span></span><br><span class="line">    <span class="keyword">float</span> x_center = <span class="number">0.5</span> * (max_x + min_x);</span><br><span class="line">    <span class="comment">// 计算点云y方向的中心坐标</span></span><br><span class="line">    <span class="keyword">float</span> y_center = <span class="number">0.5</span> * (max_y + min_y);</span><br><span class="line">    <span class="comment">// 计算图像x方向的中心像素坐标</span></span><br><span class="line">    <span class="keyword">float</span> x_center_image = image_cols / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 计算图像y方向的中心像素坐标</span></span><br><span class="line">    <span class="keyword">float</span> y_center_image = image_rows / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个RGB彩色图像，尺寸为image_rows×image_cols，初始化为白色（255,255,255）</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">image</span><span class="params">(image_rows, image_cols, CV_8UC3, cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历点云中的每个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt : cloud-&gt;points) &#123;</span><br><span class="line">        <span class="comment">// 将点的x坐标转换为图像的x像素坐标：</span></span><br><span class="line">        <span class="comment">// （点x坐标 - 点云x中心）* 分辨率倒数 + 图像x中心像素</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in"><span class="keyword">int</span></span>((pt.x - x_center) * inv_r + x_center_image);</span><br><span class="line">        <span class="comment">// 将点的y坐标转换为图像的y像素坐标：</span></span><br><span class="line">        <span class="comment">// （点y坐标 - 点云y中心）* 分辨率倒数 + 图像y中心像素</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in"><span class="keyword">int</span></span>((pt.y - y_center) * inv_r + y_center_image);</span><br><span class="line">        <span class="comment">// 过滤条件：像素坐标超出图像范围，或点的z坐标不在[min_z, max_z]范围内则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= image_cols || y &lt; <span class="number">0</span> || y &gt;= image_rows || pt.z &lt; FLAGS_min_z || pt.z &gt; FLAGS_max_z) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将符合条件的点对应的像素设置为特定颜色（RGB：227,143,79，一种橙色）</span></span><br><span class="line">        image.at&lt;cv::Vec3b&gt;(y, x) = cv::<span class="built_in">Vec3b</span>(<span class="number">227</span>, <span class="number">143</span>, <span class="number">79</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成的俯视图像保存为&quot;bev.png&quot;</span></span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;./bev.png&quot;</span>, image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数：程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化glog日志系统</span></span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 设置日志输出级别：INFO及以上级别输出到stderr</span></span><br><span class="line">    FLAGS_stderrthreshold = google::INFO;</span><br><span class="line">    <span class="comment">// 开启日志彩色显示</span></span><br><span class="line">    FLAGS_colorlogtostderr = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 解析命令行参数（根据DEFINE_*宏定义的参数）</span></span><br><span class="line">    google::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查点云文件路径是否为空，为空则输出错误日志并返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (FLAGS_pcd_path.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;pcd path is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建点云指针并初始化</span></span><br><span class="line">    <span class="function">PointCloudType::Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> PointCloudType)</span></span>;</span><br><span class="line">    <span class="comment">// 从PCD文件读取点云数据到cloud中</span></span><br><span class="line">    pcl::io::<span class="built_in">loadPCDFile</span>(FLAGS_pcd_path, *cloud);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查点云是否为空，为空则输出错误日志并返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (cloud-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;cannot load cloud file&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出INFO级日志：点云包含的点数量</span></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;cloud points: &quot;</span> &lt;&lt; cloud-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 调用函数生成俯视图像</span></span><br><span class="line">    <span class="built_in">GenerateBEVImage</span>(cloud);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近邻问题"><a href="#最近邻问题" class="headerlink" title="最近邻问题"></a>最近邻问题</h3><p>最近邻问题是许多点云问题中最为基本的一个问题，也是众多匹配算法将反复调用的一个步骤。最近邻问题描述起来非常简单：在一个含 <em>n</em> 个点的点云</p>
<p> $X = {x_1,……,x_n}$中，我们会问，离某个点 $x_m$最近的点是哪一个？进一步，离它最近的 <em>k</em> 个点又有哪些？或者与它距离小于某个固定范围 <em>r</em> 的点有哪些？前者</p>
<p>称为 <em>k</em> 近邻查找（kNN），后者称为范围查找（range search）。这个看起来简单的问题处理起来却并不容易，存在众多不同的思路来解决它。我们非常关心最近</p>
<p>邻问题的求解效率，因为这个算法通常成千上万次地被调用，每一次调用增加一点点时间，就可能让匹配算法产生显著的效率差异。下面我们按照由简至难的顺序</p>
<p>地来介绍最近邻方法，这也符合算法技术的实际发展方向。</p>
<h3 id="拟合问题"><a href="#拟合问题" class="headerlink" title="拟合问题"></a>拟合问题</h3><p><strong>提取和估计基本元素</strong>。这类问题有时也属于 “检测” 或  “聚类”，更偏向感知方法。比如自动驾驶领域，很关心从点云里找出车辆、行人这些有语义的元素，用它们</p>
<p>给后续决策（比如刹车、变道）和路径规划提供数据；但在 SLAM（同时定位与建图）里，更关注用这些元素让不同时刻的点云 “对齐”（配准）。所以传统 SLAM  </p>
<p>里，关注的往往是基本、静态的元素，而非动态、带语义的 —— 毕竟让一个点和一个平面对齐容易，让两辆车的点云对齐，得做很多额外工作。</p>
<p>同样一个线性拟合问题，站在不同角度会有不同的提法。有时它被称为线性回归（Linear regression）（对直线的参数进行回归），有时也被称为主成分分析（Principal component analysis, PCA）（对点云的主要分布轴进行分析）。</p>
<h2 id="2D-SLAM"><a href="#2D-SLAM" class="headerlink" title="2D SLAM"></a>2D SLAM</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250910154929714.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250910154929714.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250910154929714"></p>
<ol>
<li><strong>激光扫描的基本单位</strong>：2D 激光传感器会一圈一圈地往外测距离，每一圈的所有数据合起来叫一次 “扫描（scan）”。</li>
<li><strong>怎么确定机器人位置（扫描匹配）</strong>：要知道这次扫描时机器人在哪儿、朝向哪（位姿），得用 “扫描匹配” 算法 —— 要么把当前扫描和上一次的扫描对比（叫 scan to scan），要么和已有的地图对比（叫 scan to map），原理差不多，实际能用得很灵活。</li>
<li><strong>地图的管理方式（子地图模式）</strong>：扫描的位姿估计好后，得把它放到地图里。如果简单按时间顺序堆所有扫描，误差会越积越多，还容易被移动物体（比如路过的车、人）干扰。现在常用 “子地图”：把相邻的几次扫描打包成一个  “子地图”，再把这些子地图拼起来。子地图内部是固定的，不用重复计算；每个子地图有自己的坐标系，相互之间的位置还能调整优化。处理  “回环”（机器人回到之前去过的地方）时，直接拿子地图当 “积木块” 调整就行，比早期只用一张大地图灵活方便多了。</li>
<li><strong>地图的存储与更新</strong>：地图得能区分 “哪里能走” 和 “哪里是障碍物”。常用 “占据栅格地图” 来管理，它能把移动物体的干扰过滤掉，让地图更 “干净”（比如路过的车开走后，地图里不会还留着它的痕迹）。</li>
</ol>
<h3 id="扫描匹配算法"><a href="#扫描匹配算法" class="headerlink" title="扫描匹配算法"></a>扫描匹配算法</h3><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/6_2扫描匹配.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/6_2扫描匹配.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h4 id="点到点的Scan-Matching"><a href="#点到点的Scan-Matching" class="headerlink" title="点到点的Scan Matching"></a>点到点的Scan Matching</h4><p>使用Opencv显示二维雷达数据</p>
<p>第一句 <code>DEFINE_string(bag_path, &quot;./dataset/...&quot;, &quot;数据包路径&quot;);</code></p>
<p>这是使用<code>gflags</code>库定义一个<strong>命令行参数</strong>：定义了一个名为<code>bag_path</code>的字符串类型参数，<code>gflags</code>会自动生成一个对应的全局变量<code>FLAGS_bag_path</code>（通常位于</p>
<p><code>fLS</code>命名空间下，即<code>fLS::FLAGS_bag_path</code>），用于存储该参数的值（若运行时通过命令行指定新路径，会覆盖默认值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ch6/lidar_2d_utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common/io_utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_string</span>(bag_path, <span class="string">&quot;./dataset/sad/2dmapping/test_2d_lidar.bag&quot;</span>, <span class="string">&quot;数据包路径&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 测试从rosbag中读取2d scan并plot的结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);  <span class="comment">//初始化glog日志系统</span></span><br><span class="line">    FLAGS_stderrthreshold = google::INFO; <span class="comment">// 设置glog输出到标准错误流（stderr）的日志级别阈值。</span></span><br><span class="line">    FLAGS_colorlogtostderr = <span class="literal">true</span>; <span class="comment">// 开启glog在标准错误流（stderr）中输出彩色日志。</span></span><br><span class="line">    google::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>); <span class="comment">// 使用gflags库解析命令行参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">sad::RosbagIO <span class="title">rosbag_io</span><span class="params">(fLS::FLAGS_bag_path)</span></span>;</span><br><span class="line">    <span class="comment">// 2. 为2D激光雷达数据注册处理回调函数</span></span><br><span class="line">    <span class="comment">// AddScan2DHandle：给rosbag_io对象添加一个&quot;处理2D激光扫描数据&quot;的回调函数，参数包括：</span></span><br><span class="line">    <span class="comment">//   - 第一个参数：&quot;/pavo_scan_bottom&quot; 是要订阅的2D激光雷达数据的ROS话题名称</span></span><br><span class="line">    <span class="comment">//   - 第二个参数：lambda表达式（匿名函数），作为收到该话题数据时的处理逻辑</span></span><br><span class="line">    rosbag_io</span><br><span class="line">        .<span class="built_in">AddScan2DHandle</span>(<span class="string">&quot;/pavo_scan_bottom&quot;</span>,</span><br><span class="line">                         [](Scan2d::Ptr scan) &#123;  <span class="comment">// 回调函数接收一个2D激光扫描数据指针（Scan2d::Ptr）</span></span><br><span class="line">                             cv::Mat image;  <span class="comment">// 定义一个OpenCV图像矩阵，用于存储可视化结果</span></span><br><span class="line">                             <span class="comment">// 调用sad::Visualize2DScan函数，将2D激光扫描数据转换为图像</span></span><br><span class="line">                             <span class="comment">// 参数说明：</span></span><br><span class="line">                             <span class="comment">//   - scan：输入的2D激光数据</span></span><br><span class="line">                             <span class="comment">//   - SE2()：位姿参数（此处为单位位姿，表示不进行坐标变换）</span></span><br><span class="line">                             <span class="comment">//   - image：输出的图像（存储可视化结果）</span></span><br><span class="line">                             <span class="comment">//   - Vec3b(255, 0, 0)：激光点在图像中的颜色（红色，BGR格式）</span></span><br><span class="line">                             sad::<span class="built_in">Visualize2DScan</span>(scan, <span class="built_in">SE2</span>(), image, <span class="built_in">Vec3b</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                             <span class="comment">// 显示图像：创建名为&quot;scan&quot;的窗口，显示image</span></span><br><span class="line">                             cv::<span class="built_in">imshow</span>(<span class="string">&quot;scan&quot;</span>, image);</span><br><span class="line">                             <span class="comment">// 等待20毫秒：让图像有时间显示，同时处理窗口事件（如关闭窗口）</span></span><br><span class="line">                             cv::<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">                             <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回true表示回调处理成功</span></span><br><span class="line">                         &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开始处理数据包</span></span><br><span class="line">    <span class="comment">// 调用Go()方法，启动rosbag_io的主逻辑：</span></span><br><span class="line">    <span class="comment">//   - 打开并读取bag文件中&quot;/pavo_scan_bottom&quot;话题的2D激光数据</span></span><br><span class="line">    <span class="comment">//   - 每读取一帧数据，就触发上面注册的lambda回调函数（即可视化并显示）</span></span><br><span class="line">	.<span class="built_in">Go</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>末端点有两层物理含义：（1）末端点本身表示一个实际存在的障碍物；（2）从传感器到末端点的连线上，不存在其他的障碍物。注意第 2 层含义需要计算传感器</p>
<p>到末端点的连线（传感器并不会测量这条连线。它只能测量末端点，所以这条连线的方程需要我们自己计算）。如果我们还想计算这条连线经过哪些栅格，就会涉</p>
<p>及到光线投射算法（ray casting）和栅格化算法（rasterization）。</p>
<p><strong>数学模型</strong></p>
<p>从状态估计的角度来看，2D 激光的扫描数据可以记作观测数据 $z$。它是由机器人在位姿 $x$ 上对某张地图进 $m$行观测之后得到的数据。其中$\omega$为噪声项。</p>
<script type="math/tex; mode=display">
z=h(x, m) + \omega</script><p>的目的是根据观测到的$z$和$m$来估计$x$。根据贝叶斯估计理论，$x$可以通过<strong>最大后验</strong>（Maximum of a posterior, MAP）或<strong>最大似然</strong>（Maximum of likelihood </p>
<p>estimation,MLE）估计得到：</p>
<script type="math/tex; mode=display">
x_{\text{MLE}} = \arg\max p(\boldsymbol{x}|z, \boldsymbol{m}) = \arg\max p(z|\boldsymbol{x}, \boldsymbol{m})</script><p><strong>核心是 “怎么让两次激光扫描对上号”</strong></p>
<p>当只考虑 “当前扫描和上一次扫描匹配（scan to scan）” 时，关键是定义<strong>观测方程</strong>（算出 “预测和实际的差距”，也就是残差）。</p>
<p>如何定义观测方程的详细形式，即为每一个观测数据计算残差项。常见的方法：点到点的 scan matching （迭代最近算法 ICP）, 点到线的 scan matching （PL-</p>
<p>ICP，或 ICL)，以及<strong>高斯似然场法</strong>（或 CSM ）。</p>
<blockquote>
<p><strong>观测方程要解决三个问题</strong></p>
<ol>
<li><strong>选哪些点来匹配</strong>：理论上所有激光扫到的点都该参与，但为了速度快，会 “采样”（比如均匀选点、随机选点，或者按点的法线、特征来选）。</li>
<li><strong>扫描点对应地图哪个点</strong>：通常用 “最近邻” 法 —— 假设当前估计的位置附近，地图里最近的点就是匹配点；也可以从地图的栅格或 “场” 里找最近的点。</li>
<li><strong>怎么算差距（残差）</strong>：激光本身的噪声模型很复杂，实际常用简化版，比如直接当成 “二维高斯分布”（误差像正态分布那样，均值为 0，方差用 Σ 表示）。</li>
</ol>
</blockquote>
<h4 id="点到点的ICP-算法"><a href="#点到点的ICP-算法" class="headerlink" title="点到点的ICP 算法"></a>点到点的ICP 算法</h4><p>把 “扫描匹配” 拆成两步：<strong>数据关联</strong>（找扫描点和地图点的对应关系）+ <strong>位姿估计</strong>（算机器人的位置和朝向），然后交替做这两步，直到结果稳定。只要算法是 “交</p>
<p>替这两步”，都算 “类 ICP” 算法。如果提前知道匹配关系，ICP 能直接解方程，但这样会少了 <strong>“过滤错误点（异常点）”</strong>  的机会，不过从优化角度看，点到点、点到</p>
<p>面的方法其实是相通的。这里就用 “残差 + 优化” 的形式来讲解这些算法。</p>
<p>用<strong>高斯牛顿法</strong>来实现 “二维点云对齐（ICP）”。每次迭代时，要做两件核心事：</p>
<ul>
<li>找 “最近的点对”（比如把新扫描的点，和地图里已有的点一一对应起来，找距离最近的那个）K-d数查找；</li>
<li>用高斯牛顿的方法，根据这些最近点对，算出 “机器人位姿（位置 + 朝向）该怎么微调”，反复迭代，直到点云对齐得足够好。</li>
</ul>
<p><strong>高斯牛顿迭代函数</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43175007/article/details/106164569">最小二乘法求解 梯度下降法，牛顿法，高斯牛顿法</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数功能：使用高斯牛顿法实现2D ICP（迭代最近点）算法，对齐源激光扫描和目标点云，优化位姿</span></span><br><span class="line"><span class="comment">// 参数：init_pose - 初始位姿（输入），优化后的位姿会通过该参数输出</span></span><br><span class="line"><span class="comment">// 返回值：bool - 对齐是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Icp2d::AlignGaussNewton</span><span class="params">(SE2&amp; init_pose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iterations = <span class="number">10</span>;  <span class="comment">// 高斯牛顿迭代次数，设置为10次</span></span><br><span class="line">    <span class="keyword">double</span> cost = <span class="number">0</span>, lastCost = <span class="number">0</span>;  <span class="comment">// 当前迭代的代价和上一次迭代的代价（用于判断收敛）</span></span><br><span class="line">    SE2 current_pose = init_pose;  <span class="comment">// 当前位姿，初始化为输入的初始位姿</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> max_dis2 = <span class="number">0.01</span>;    <span class="comment">// 最近邻匹配的最大距离平方（用于筛选有效匹配点，单位：m²）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> min_effect_pts = <span class="number">20</span>;  <span class="comment">// 最小有效匹配点数（低于此值则认为对齐失败）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始高斯牛顿迭代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iter = <span class="number">0</span>; iter &lt; iterations; ++iter) &#123;</span><br><span class="line">        Mat3d H = Mat3d::<span class="built_in">Zero</span>();  <span class="comment">// 3x3海森矩阵（Hessian matrix），用于构建线性方程组，初始化为零</span></span><br><span class="line">        Vec3d b = Vec3d::<span class="built_in">Zero</span>();  <span class="comment">// 3维向量，线性方程组Hx = b的右侧，初始化为零</span></span><br><span class="line">        cost = <span class="number">0</span>;  <span class="comment">// 重置当前迭代的代价</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> effective_num = <span class="number">0</span>;  <span class="comment">// 有效匹配点的数量（用于判断结果可靠性）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历源激光扫描的每个点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; source_scan_-&gt;ranges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">float</span> r = source_scan_-&gt;ranges[i];  <span class="comment">// 获取当前激光点的距离值（极坐标的r）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 过滤掉超出激光有效测距范围的点（距离过近或过远）</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; source_scan_-&gt;range_min || r &gt; source_scan_-&gt;range_max) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前激光点的角度（极坐标的θ）：起始角度 + 索引×角度增量</span></span><br><span class="line">            <span class="keyword">float</span> angle = source_scan_-&gt;angle_min + i * source_scan_-&gt;angle_increment;</span><br><span class="line">            <span class="comment">// 获取当前位姿的旋转角（将SO2类型的旋转转换为角度，通过对数映射）</span></span><br><span class="line">            <span class="keyword">float</span> theta = current_pose.<span class="built_in">so2</span>().<span class="built_in">log</span>();</span><br><span class="line">            <span class="comment">// 将源激光点从自身极坐标转换为世界坐标系下的直角坐标（通过当前位姿变换）</span></span><br><span class="line">            Vec2d pw = current_pose * <span class="built_in">Vec2d</span>(r * std::<span class="built_in">cos</span>(angle), r * std::<span class="built_in">sin</span>(angle));</span><br><span class="line">            <span class="comment">// 转换为Point2d类型（方便kdtree搜索）</span></span><br><span class="line">            Point2d pt;</span><br><span class="line">            pt.x = pw.<span class="built_in">x</span>();</span><br><span class="line">            pt.y = pw.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在目标点云中搜索当前点的最近邻（用kdtree加速搜索）</span></span><br><span class="line">            std::vector&lt;<span class="keyword">int</span>&gt; nn_idx;  <span class="comment">// 存储最近邻点的索引</span></span><br><span class="line">            std::vector&lt;<span class="keyword">float</span>&gt; dis;   <span class="comment">// 存储与最近邻点的距离（平方）</span></span><br><span class="line">            kdtree_.<span class="built_in">nearestKSearch</span>(pt, <span class="number">1</span>, nn_idx, dis);  <span class="comment">// 搜索1个最近邻</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果找到最近邻，且距离平方小于最大阈值（有效匹配）</span></span><br><span class="line">            <span class="keyword">if</span> (nn_idx.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; dis[<span class="number">0</span>] &lt; max_dis2) &#123;</span><br><span class="line">                effective_num++;  <span class="comment">// 有效点数量加1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构建雅可比矩阵J（3x2）：误差对状态变量（x, y, θ）的偏导数</span></span><br><span class="line">                <span class="comment">// 注：这里状态变量为[x, y, θ]，误差为2维（x方向和y方向）</span></span><br><span class="line">                Mat32d J;</span><br><span class="line">                J &lt;&lt; <span class="number">1</span>, <span class="number">0</span>,  <span class="comment">// x误差对x的偏导=1，对y的偏导=0</span></span><br><span class="line">                     <span class="number">0</span>, <span class="number">1</span>,  <span class="comment">// y误差对x的偏导=0，对y的偏导=1</span></span><br><span class="line">                     -<span class="function">r * <span class="title">std::sin</span><span class="params">(angle + theta)</span>, r * <span class="title">std::cos</span><span class="params">(angle + theta)</span></span>;  <span class="comment">// 误差对θ的偏导</span></span><br><span class="line"></span><br><span class="line">                H += J * J.<span class="built_in">transpose</span>();  <span class="comment">// 累加海森矩阵（H = ΣJ*J^T）</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算误差向量e：源点转换后的坐标 - 目标点坐标（x方向和y方向）</span></span><br><span class="line">                <span class="function">Vec2d <span class="title">e</span><span class="params">(pt.x - target_cloud_-&gt;points[nn_idx[<span class="number">0</span>]].x, pt.y - target_cloud_-&gt;points[nn_idx[<span class="number">0</span>]].y)</span></span>;</span><br><span class="line">                b += -J * e;  <span class="comment">// 累加b向量（b = -ΣJ*e）</span></span><br><span class="line"></span><br><span class="line">                cost += e.<span class="built_in">dot</span>(e);  <span class="comment">// 累加误差的平方（用于计算总代价）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有效匹配点数量少于最小要求，返回失败</span></span><br><span class="line">        <span class="keyword">if</span> (effective_num &lt; min_effect_pts) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解线性方程组H*dx = b，求位姿增量dx（用LDLT分解求解，适合对称正定矩阵）</span></span><br><span class="line">        Vec3d dx = H.<span class="built_in">ldlt</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">        <span class="comment">// 如果解中存在NaN（数值不稳定），退出迭代</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isnan</span>(dx[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cost /= effective_num;  <span class="comment">// 计算平均代价（总代价/有效点数量）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ******如果不是第一次迭代，且当前代价大于等于上一次代价，说明收敛（不再下降），退出迭代*******</span></span><br><span class="line">        <span class="keyword">if</span> (iter &gt; <span class="number">0</span> &amp;&amp; cost &gt;= lastCost) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前迭代的信息：迭代次数、平均代价、有效点数量</span></span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;iter &quot;</span> &lt;&lt; iter &lt;&lt; <span class="string">&quot; cost = &quot;</span> &lt;&lt; cost &lt;&lt; <span class="string">&quot;, effect num: &quot;</span> &lt;&lt; effective_num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前位姿的平移部分：加上dx的前两位（x和y方向的增量）</span></span><br><span class="line">        current_pose.<span class="built_in">translation</span>() += dx.head&lt;<span class="number">2</span>&gt;();</span><br><span class="line">        <span class="comment">// 更新当前位姿的旋转部分：用SO2的指数映射将角度增量dx[2]转换为旋转，与当前旋转复合</span></span><br><span class="line">        current_pose.<span class="built_in">so2</span>() = current_pose.<span class="built_in">so2</span>() * SO2::<span class="built_in">exp</span>(dx[<span class="number">2</span>]);</span><br><span class="line">        lastCost = cost;  <span class="comment">// 记录当前代价，用于下一次迭代的收敛判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_pose = current_pose;  <span class="comment">// 将优化后的位姿赋给输入参数（输出结果）</span></span><br><span class="line">    <span class="comment">// 输出最终估计的位姿：平移向量和旋转角（弧度）</span></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;estimated pose: &quot;</span> &lt;&lt; current_pose.<span class="built_in">translation</span>().<span class="built_in">transpose</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, theta: &quot;</span> &lt;&lt; current_pose.<span class="built_in">so2</span>().<span class="built_in">log</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 对齐成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入gflags库，用于解析命令行参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入glog库，用于日志输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入OpenCV的高层GUI模块，用于图像显示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入2D ICP算法的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ch6/icp_2d.h&quot;</span></span></span><br><span class="line"><span class="comment">// 引入2D激光雷达工具函数的头文件（如可视化等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ch6/lidar_2d_utils.h&quot;</span></span></span><br><span class="line"><span class="comment">// 引入通用IO工具函数的头文件（如ROS数据包读取等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common/io_utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命令行参数：数据包路径，默认值为&quot;./dataset/sad/2dmapping/floor1.bag&quot;</span></span><br><span class="line"><span class="built_in">DEFINE_string</span>(bag_path, <span class="string">&quot;./dataset/sad/2dmapping/floor1.bag&quot;</span>, <span class="string">&quot;数据包路径&quot;</span>);</span><br><span class="line"><span class="comment">// 定义命令行参数：2D ICP匹配方法，可选&quot;point2point&quot;（点到点）或&quot;point2plane&quot;（点到面），默认点到点</span></span><br><span class="line"><span class="built_in">DEFINE_string</span>(method, <span class="string">&quot;point2point&quot;</span>, <span class="string">&quot;2d icp方法：point2point/point2plane&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 程序功能：从ROS数据包（.bag）中读取2D激光雷达数据，使用指定的ICP方法（点到点或点到面）对连续帧进行配准，并可视化结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化glog日志系统</span></span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 设置日志输出级别：INFO及以上级别输出到stderr</span></span><br><span class="line">    FLAGS_stderrthreshold = google::INFO;</span><br><span class="line">    <span class="comment">// 开启日志彩色显示</span></span><br><span class="line">    FLAGS_colorlogtostderr = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 解析命令行参数（根据DEFINE_*宏定义的参数）</span></span><br><span class="line">    google::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ROS数据包读取器对象rosbag_io，传入命令行指定的bag文件路径</span></span><br><span class="line">    <span class="function">sad::RosbagIO <span class="title">rosbag_io</span><span class="params">(fLS::FLAGS_bag_path)</span></span>;</span><br><span class="line">    <span class="comment">// 定义指针，分别存储上一帧激光扫描数据（last_scan）和当前帧激光扫描数据（current_scan）</span></span><br><span class="line">    Scan2d::Ptr last_scan = <span class="literal">nullptr</span>, current_scan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 核心逻辑：读取激光数据，对连续帧进行ICP配准并可视化</span></span><br><span class="line">    <span class="comment">// 给rosbag_io注册&quot;/pavo_scan_bottom&quot;话题的2D激光数据处理回调函数</span></span><br><span class="line">    rosbag_io</span><br><span class="line">        .<span class="built_in">AddScan2DHandle</span>(<span class="string">&quot;/pavo_scan_bottom&quot;</span>,</span><br><span class="line">                         [&amp;](Scan2d::Ptr scan) &#123;  <span class="comment">// 回调函数，接收当前帧激光数据scan</span></span><br><span class="line">                             current_scan = scan;  <span class="comment">// 将当前激光数据赋值给current_scan</span></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 如果是第一帧数据（last_scan为空），则将当前帧设为上一帧，不进行配准</span></span><br><span class="line">                             <span class="keyword">if</span> (last_scan == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                                 last_scan = current_scan;</span><br><span class="line">                                 <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 继续处理下一帧</span></span><br><span class="line">                             &#125;</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 创建2D ICP对象icp</span></span><br><span class="line">                             sad::Icp2d icp;</span><br><span class="line">                             <span class="comment">// 设置ICP的目标点云为上一帧激光数据（last_scan）</span></span><br><span class="line">                             icp.<span class="built_in">SetTarget</span>(last_scan);</span><br><span class="line">                             <span class="comment">// 设置ICP的源点云为当前帧激光数据（current_scan）</span></span><br><span class="line">                             icp.<span class="built_in">SetSource</span>(current_scan);</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 定义位姿变量pose，用于存储ICP配准得到的当前帧相对于上一帧的变换</span></span><br><span class="line">                             SE2 pose;</span><br><span class="line">                             <span class="comment">// 根据命令行参数选择ICP方法：点到点或点到面</span></span><br><span class="line">                             <span class="keyword">if</span> (fLS::FLAGS_method == <span class="string">&quot;point2point&quot;</span>) &#123;</span><br><span class="line">                                 <span class="comment">// 调用点到点的高斯牛顿ICP进行配准</span></span><br><span class="line">                                 icp.<span class="built_in">AlignGaussNewton</span>(pose);</span><br><span class="line">                             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fLS::FLAGS_method == <span class="string">&quot;point2plane&quot;</span>) &#123;</span><br><span class="line">                                 <span class="comment">// 调用点到面的高斯牛顿ICP进行配准</span></span><br><span class="line">                                 icp.<span class="built_in">AlignGaussNewtonPoint2Plane</span>(pose);</span><br><span class="line">                             &#125;</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 创建图像矩阵，用于可视化激光数据</span></span><br><span class="line">                             cv::Mat image;</span><br><span class="line">                             <span class="comment">// 可视化上一帧激光数据（目标点云），位姿为单位位姿（SE2()），颜色设为蓝色（BGR: 255,0,0）</span></span><br><span class="line">                             sad::<span class="built_in">Visualize2DScan</span>(last_scan, <span class="built_in">SE2</span>(), image, <span class="built_in">Vec3b</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                             <span class="comment">// 可视化当前帧激光数据（源点云），位姿为ICP配准得到的pose，颜色设为红色（BGR: 0,0,255）</span></span><br><span class="line">                             sad::<span class="built_in">Visualize2DScan</span>(current_scan, pose, image, <span class="built_in">Vec3b</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">                             <span class="comment">// 显示可视化图像，窗口名为&quot;scan&quot;</span></span><br><span class="line">                             cv::<span class="built_in">imshow</span>(<span class="string">&quot;scan&quot;</span>, image);</span><br><span class="line">                             <span class="comment">// 等待20毫秒，让图像有时间显示，同时处理窗口事件</span></span><br><span class="line">                             cv::<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 将当前帧设为下一帧的上一帧，准备处理下一帧</span></span><br><span class="line">                             last_scan = current_scan;</span><br><span class="line">                             <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 继续处理下一帧</span></span><br><span class="line">                         &#125;)</span><br><span class="line">        <span class="comment">// 启动数据包读取和处理（触发上述回调函数）</span></span><br><span class="line">        .<span class="built_in">Go</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="似然场"><a href="#似然场" class="headerlink" title="似然场"></a>似然场</h4><ol>
<li>ICP <strong>方法的局限</strong></li>
</ol>
<p>点到点 / 点到线的 ICP（迭代最近点）能让激光扫描之间对齐，也能和地图对齐。但二维 SLAM 里，地图常存成<strong>占据栅格地图</strong>（像网格拼图，还能过滤动态物体，</p>
<p>比如开走的车）。这时 ICP 每次迭代都要重新找 “最近点对”（像给点装 “弹簧” 拉对齐），效率不高。</p>
<p><strong>2. 似然场法的 “聪明思路”</strong></p>
<p>把点云想象成有 “吸引力场”：</p>
<ul>
<li>不像 ICP 那样 “点对点装弹簧”，而是让点云周围形成一个 “场”，附近的点会被这个场吸引，<strong>距离越远，吸引力衰减得越快</strong>（比如按距离平方或高斯规律减弱）。</li>
<li>激光测到的点落在这个场附近时，用场的 “强弱” 来算误差，不用每次都重新配对点，更高效。</li>
</ul>
<ol>
<li><strong>似然场的应用</strong></li>
</ol>
<p>它既能让两次扫描对齐，也能让扫描和地图（尤其是栅格地图）对齐。生成时，会在每个点周围 “画” 一个<strong>随距离变淡的圆圈</strong>（提前做好，固定不变）；后续栅格地</p>
<p>图也能生成自己的似然场，还能和 “子地图” 结合，实现快速对齐。</p>
<h3 id="珊格地图"><a href="#珊格地图" class="headerlink" title="珊格地图"></a>珊格地图</h3><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/6_3构建地图.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/6_3构建地图.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<p>SLAM（同时定位与建图）里，“扫描匹配” 能确定激光扫描和地图的相对位置后，就要考虑 “怎么建图”。早期直接建一整张图有局限，现在常用更灵活的<strong>栅格地图 + 子地图</strong>模式。</p>
<h4 id="占据栅格地图是啥"><a href="#占据栅格地图是啥" class="headerlink" title="占据栅格地图是啥"></a>占据栅格地图是啥</h4><p>把地图分成很多小方格（栅格），每个方格存 “有没有障碍物” 的<strong>概率</strong>。它形式简单、灵活：既可以存 “这里有没有障碍”（用于机器人找路），也能存 “语义信息”（比如区分是车还是人）；而且和图像关联紧密，用 OpenCV 这类图像库就能存和显示。</p>
<h4 id="怎么用激光更新栅格概率"><a href="#怎么用激光更新栅格概率" class="headerlink" title="怎么用激光更新栅格概率"></a>怎么用激光更新栅格概率</h4><ul>
<li>初始时，每个栅格 “有障碍” 的概率设为 0.5（因为不知道有没有）。</li>
<li>激光多次扫到某个栅格有物体，它的 “有障碍概率” 会慢慢升到 1；多次扫到能通行，概率降到 0。</li>
<li>2D 激光的特点：激光打到的 “末端点” 所在栅格是 “被占据（有障碍）”，激光从车身到末端点的连线经过的栅格是 “可通行”—— 所以能靠激光数据，方便地更新每个栅格的 “占据情况”。</li>
</ul>
<h4 id="两种栅格的区别"><a href="#两种栅格的区别" class="headerlink" title="两种栅格的区别"></a>两种栅格的区别</h4><ul>
<li>占据栅格：概率 1 = 有障碍物。</li>
<li>通行栅格：概率 0 = 能通行。<br>两者只是 “概率含义相反”，本质都能表示地图，实际用的时候可以自由选。</li>
</ul>
<p>栅格地图里的每个小格子，存的是 “这个格子被障碍物占了的概率”（不是非黑即白说 “有” 或 “没有”）。比如：</p>
<ul>
<li>反复观测到某个格子有障碍，概率会慢慢升高；</li>
<li>要是格子先有物体、后来物体又移走了，概率会先升、之后再下降</li>
</ul>
<p>二维激光发射后，<strong>激光打到的终点格子</strong>，判定为 “有障碍（占据）”；<strong>从激光传感器到终点的路径上的格子</strong>，判定为 “空白（没障碍）”。</p>
<p>但这招只适合 “完全平的二维场景”：如果机器人有高度（比如要爬台阶），或者激光发射角度歪了，就不准了 —— 因为二维激光测不到 “高度方向的障碍”（比如台阶、桌子这类，会挡路，但二维栅格地图看不出来）。</p>
<p>把连续的激光线条，转换成每个格子的 “概率增减”，这个过程叫<strong>栅格化</strong>。如果激光角度特别细、测距特别远，栅格化会很慢。所以有两种做法：</p>
<ul>
<li>对<strong>每条激光线单独做栅格化</strong>；</li>
<li>提前算一个 “固定大小的模板区域”，再对模板里的点做栅格化。<br>后面会实现这两种方法，对比谁更快、更好用。</li>
</ul>
<h4 id="基于模板的地图生成"><a href="#基于模板的地图生成" class="headerlink" title="基于模板的地图生成"></a>基于模板的地图生成</h4><p><strong>栅格填充的 “模板技巧”</strong></p>
<p>如果激光测距很远（比如 100 - 200 米），或者不想用复杂的直线填充算法，就用<strong>模板法</strong>：提前做一个 “模板区域”，里面每个小格子的角度、距离都是预先算好的。更新地图时，把模板里的格子距离和激光实际测得的距离对比：</p>
<ul>
<li>模板格子距离 <strong>比激光测得的近</strong>——这个格子是 “空白”（没障碍）；</li>
<li>模板格子距离 <strong>和激光测得的一样</strong> —— 这个格子 “被占据”（有障碍）；</li>
<li>模板格子距离 <strong>比激光测得的远</strong>—— 不管这个格子。<br>这样就不用给每条激光线单独做 “栅格化”，更省事。</li>
</ul>
<p><strong>概率更新的 “偷懒方法”</strong></p>
<p>理论上，栅格该存 “0 - 1 之间的占据概率”，但计算要用到对数、指数，很麻烦。工程上直接用 图像灰度值（0 - 255） 代替：</p>
<ul>
<li>灰度值 127——  这个格子 “未知”（没测过）；</li>
<li>每次检测到障碍—— 灰度值减 1；</li>
<li>没检测到障碍—— 灰度值加 1；</li>
<li>同时限制灰度值的最大、最小计数（比如不低于 0、不高于 255）。<br>这样既统计了 “看到障碍的次数”，又省了复杂计算。</li>
</ul>
<p><strong>实现时的几个要点</strong></p>
<p>后面要用 “子地图” 管理地图和回环检测，所以：</p>
<ul>
<li>每个子地图都生成自己的占据栅格地图，用子地图的坐标系（没做回环修正时，就是地图坐标系）；</li>
<li>占据栅格地图会和之前讲的 “似然场” 结合，且用栅格里已经标为 “障碍” 的部分来生成似然场；</li>
<li>先讲怎么用二维激光扫描生成<strong>局部栅格地图</strong>，下一节再讲多个栅格地图如何合并成<strong>全局地图</strong>。<br>代码里最核心的是 “栅格化算法”：知道激光扫描的位姿后，用模板法判断哪些格子是障碍、哪些能通行。</li>
</ul>
<h4 id="子地图"><a href="#子地图" class="headerlink" title="子地图"></a>子地图</h4><p><strong>原理</strong></p>
<p><strong>子地图是 “中间打包层”</strong>：把多个匹配好的激光扫描数据，组合成一个个 “子地图”。它比单个扫描大、比全局地图小，不管 2D 还是 3D 激光 SLAM，用起来都</p>
<p>灵活。</p>
<p><strong>子地图的位姿能单独调</strong>：每个子地图有自己的 “位置 + 朝向”（用$T_{WS}$表示，描述子地图在世界坐标系里的状态）。当新激光扫描（记为C）来匹配时，先算 “扫描</p>
<p>相对于子地图的位置关系”（$T_{SC}$）。那扫描在世界里的最终位置，就是 “子地图在世界的位置” 乘 “扫描相对于子地图的位置”。</p>
<script type="math/tex; mode=display">
T_{WC} = T_{WS}T_{SC}</script><p><strong>修图更方便</strong>：这种做法的好处是，要是后期发现地图整体有偏差（比如回环检测到重复区域），不用修改子地图内部每个扫描的相对位置，只需要调整每个子地图</p>
<p>自己的$T_{WS}$就行。回环检测时，把每个子地图当一个 “小积木” 来处理，不用纠结每个激光帧的细节，效率更高。</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>每个子地图都配套 “似然场”（辅助匹配的工具）和 “栅格地图”（存地图的网格）。</li>
<li>每次新的激光扫描数据，都和<strong>当前子地图</strong>匹配，算出扫描在这个子地图里的 “位置 + 朝向（位姿）”。</li>
<li>机器人移动 / 转动到一定距离、角度时，选一个 “关键帧”（把此时的扫描当成重要节点）。</li>
<li>若机器人超出当前子地图范围，或子地图里的关键帧太多，就<strong>新建子地图</strong>：新子地图以当前扫描为中心，它在世界中的位姿设为$T_{WS} =T_{WC}$；新地图初始没数据，为了后续好匹配，把旧子地图里最近的关键帧复制过来。</li>
<li>把所有子地图的栅格地图 “拼起来”，就得到<strong>全局地图</strong>。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>pose_</code></td>
<td style="text-align:center"><code>SE2</code></td>
<td style="text-align:center">子地图在世界坐标系中的位姿（Tws），<code>SE2</code>表示二维位姿（包含 x、y 平移和旋转角）</td>
</tr>
<tr>
<td style="text-align:center"><code>id_</code></td>
<td style="text-align:center"><code>size_t</code></td>
<td style="text-align:center">子地图的唯一标识 ID，默认 0</td>
</tr>
<tr>
<td style="text-align:center"><code>frames_</code></td>
<td style="text-align:center"><code>std::vector&lt;std::shared_ptr&lt;Frame&gt;&gt;</code></td>
<td style="text-align:center">存储属于该子地图的所有关键帧（<code>Frame</code>为传感器帧数据结构）</td>
</tr>
<tr>
<td style="text-align:center"><code>field_</code></td>
<td style="text-align:center"><code>LikelihoodField</code></td>
<td style="text-align:center">似然场（一种概率地图，用于快速匹配传感器数据与地图）</td>
</tr>
<tr>
<td style="text-align:center"><code>occu_map_</code></td>
<td style="text-align:center"><code>OccupancyMap</code></td>
<td style="text-align:center">占据栅格地图（用栅格表示环境中 “占据” 或 “空闲” 的区域）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子地图类</span></span><br><span class="line"><span class="comment"> * 子地图关联到若干个关键帧，也会维护自己的栅格地图与似然场</span></span><br><span class="line"><span class="comment"> * 往子地图中添加关键帧时，会更新它的栅格地图与似然场</span></span><br><span class="line"><span class="comment"> * 子地图有自己的pose，记为 Tws，每个frame的世界位姿可以由子地图的pose乘frame在子地图中的相对pose得到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Submap</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：用输入的位姿pose初始化子地图</span></span><br><span class="line">    <span class="comment">// 初始化列表中为pose_赋值，同时设置占据栅格地图和似然场的位姿与子地图一致</span></span><br><span class="line">    <span class="built_in">Submap</span>(<span class="keyword">const</span> SE2&amp; pose) : <span class="built_in">pose_</span>(pose) &#123;</span><br><span class="line">        occu_map_.<span class="built_in">SetPose</span>(pose_);  <span class="comment">// 为占据栅格地图设置位姿（与子地图位姿相同）</span></span><br><span class="line">        field_.<span class="built_in">SetPose</span>(pose_);     <span class="comment">// 为似然场设置位姿（与子地图位姿相同）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 把另一个submap中的占据栅格复制到本地图中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetOccuFromOtherSubmap</span><span class="params">(std::shared_ptr&lt;Submap&gt; other)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将frame与本submap进行匹配，计算frame在子地图中的相对位姿</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">MatchScan</span><span class="params">(std::shared_ptr&lt;Frame&gt; frame)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判定当前子地图关联的激光扫描数据中是否有位于子地图边界外部的点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasOutsidePoints</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将输入的帧数据添加到占据栅格地图中，更新栅格的占据状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddScanInOccupancyMap</span><span class="params">(std::shared_ptr&lt;Frame&gt; frame)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在子地图中添加一个关键帧（将frame存入frames_列表）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddKeyFrame</span><span class="params">(std::shared_ptr&lt;Frame&gt; frame)</span> </span>&#123; frames_.<span class="built_in">emplace_back</span>(frame); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当子地图的位姿（Tws）更新时，重新计算所有关键帧的世界位姿（世界位姿 = 子地图位姿 × 帧在子地图中的相对位姿）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateFramePoseWorld</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 访问器（用于外部获取或修改内部成员）</span></span><br><span class="line">    <span class="comment">// 返回占据栅格地图的引用（可用于外部读写栅格数据）</span></span><br><span class="line">    <span class="function">OccupancyMap&amp; <span class="title">GetOccuMap</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> occu_map_; &#125;</span><br><span class="line">    <span class="comment">// 返回似然场的引用（可用于外部读写似然场数据）</span></span><br><span class="line">    <span class="function">LikelihoodField&amp; <span class="title">GetLikelihood</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> field_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子地图中所有关键帧的列表（可用于外部遍历或修改关键帧）</span></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Frame&gt;&gt;&amp; <span class="built_in">GetFrames</span>() &#123; <span class="keyword">return</span> frames_; &#125;</span><br><span class="line">    <span class="comment">// 返回子地图中关键帧的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">NumFrames</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> frames_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子地图的唯一标识ID</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetId</span><span class="params">(<span class="keyword">size_t</span> id)</span> </span>&#123; id_ = id; &#125;</span><br><span class="line">    <span class="comment">// 获取子地图的唯一标识ID</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> id_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子地图的位姿（通常会同步更新栅格地图、似然场和关键帧的世界位姿）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPose</span><span class="params">(<span class="keyword">const</span> SE2&amp; pose)</span></span>;</span><br><span class="line">    <span class="comment">// 获取子地图当前的位姿（Tws，子地图在世界坐标系中的位姿）</span></span><br><span class="line">    <span class="function">SE2 <span class="title">GetPose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pose_; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    SE2 pose_;  <span class="comment">// 子地图在世界坐标系中的位姿，记为Tws（包含x、y平移和旋转角）</span></span><br><span class="line">    <span class="keyword">size_t</span> id_ = <span class="number">0</span>;  <span class="comment">// 子地图的唯一标识ID，初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储属于当前子地图的所有关键帧（每个关键帧包含传感器数据和相对子地图的位姿）</span></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Frame&gt;&gt; frames_;</span><br><span class="line">    LikelihoodField field_;  <span class="comment">// 似然场（概率地图，用于快速匹配传感器帧与子地图）</span></span><br><span class="line">    OccupancyMap occu_map_;  <span class="comment">// 占据栅格地图（用栅格表示环境中占据/空闲状态，用于构建子地图）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911115006258.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911115006258.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250911115006258" style="zoom:50%;" /></p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911115025820.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911115025820.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250911115025820" style="zoom:50%;" /></p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911115045932.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911115045932.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250911115045932"></p>
<h3 id="回环检测与闭环"><a href="#回环检测与闭环" class="headerlink" title="回环检测与闭环"></a>回环检测与闭环</h3><p><strong>1.选哪些历史地图来检测？</strong></p>
<p>得找出和当前扫描位置<strong>可能重叠</strong>的旧地图。但如果之前攒的误差太大，估计的轨迹不准，就可能选错该匹配的地图，导致回环没检测对。所以得对 “误差大概有多大” 有个基本判断，才能选对检测对象。</p>
<p><strong>2. 回环的匹配方法，和里程计里的不一样</strong></p>
<p>里程计是 “连续运动” 的，默认<strong>初始位姿和最终最优结果差别不大</strong>。但回环时，因为误差累计，初始估计的位姿可能差得很远。这时候原来的 ICP（迭代最近点）、似然场这些方法就不好使了，得用能处理 “初始位姿差很多” 的方法，比如<strong>网格搜索、粒子滤波、分枝定界、图像金字塔</strong>这些，它们能在大误差下找到正确匹配。</p>
<p><strong>3. 回环后，怎么修正地图？</strong></p>
<p>检测到回环，就得调整整个地图的位姿。可以基于<strong>关键帧</strong>的位姿来优化，也可以基于<strong>子地图</strong>：子地图数量少，用它优化更省事，但子地图优化没法修复 “单个子地图内部的变形”，所以有些系统还是得用关键帧作为基本单元来优化。</p>
<h4 id="多分辨率回环检测"><a href="#多分辨率回环检测" class="headerlink" title="多分辨率回环检测"></a>多分辨率回环检测</h4><p>金字塔式回环检测（也叫 “由粗到精”“多分辨率配准”），核心是一种 <strong>“先粗略对齐，再精细调整” 的思路 </strong>—— 不光用于点云匹配，在计算机视觉（比如光流法）、数学规划（比如分枝定界法）里也很常用，目的是快速找最优解，还不影响效果。</p>
<p>具体到 “多分辨率似然场匹配”（属于扫描匹配，解决 “初始位姿估计不准” 的问题）：<br>因为初始位姿误差大时，激光点容易出现大偏差，甚至被误判为 “异常值” 删掉。所以我们做<strong>多个 “清晰度不同” 的似然场</strong>（比如低分辨率、高分辨率）：</p>
<ul>
<li>低分辨率似然场像 “打了马赛克的地图”，障碍形状模糊、范围大，但误差也小，能先在这层 “粗略对齐”；</li>
<li>对齐后，再把结果放到  高分辨率的 “清晰版地图”里，做精细匹配。</li>
</ul>
<p>比如文中例子用了四层似然场，每层尺寸减半：最底层（小分辨率）连障碍形状都看不清，但能包容更大的初始位姿误差，先在这层 “粗配准”，再往上一层一层细化，就能解决初始位姿不准的问题。</p>
<h4 id="基于子地图的回环修正"><a href="#基于子地图的回环修正" class="headerlink" title="基于子地图的回环修正"></a>基于子地图的回环修正</h4><p>当回环检测成功找到 “当前帧与历史子地图的匹配关系” 后，就会启动<strong>回环修正</strong>，这个过程可以用 “位姿图（pose graph）” 来建模优化 —— 由于之前构建了子地图，优化时只需调整<strong>子地图的位姿</strong>，不用再管单个激光帧，很高效。</p>
<p><strong>步骤 1：推导子地图间的相对位姿</strong></p>
<p>假设：</p>
<ul>
<li>历史子地图S1在 “世界坐标系” 中的位姿是$T_{WS_1}$；</li>
<li>当前帧的位姿是TWC；</li>
<li>当前子地图S2在 “世界坐标系” 中的位姿是$T_{WS_2}$。</li>
</ul>
<p>通过 “多分辨率匹配”，能算出<strong>当前帧相对于历史子地图S1的位姿TS1C</strong>。接着，就能推导出自<strong>历史子地图S1和当前子地图S2之间的相对位姿TS1S2</strong>（用公式计算），这样就明确了两个子地图的 “对齐关系”。</p>
<script type="math/tex; mode=display">
T_{S_1S_2}=T_{S_1C}T_{WC}^{−1}T_{WS_2}</script><p><strong>步骤 2：位姿图优化（调整子地图位姿）</strong></p>
<p>把<strong>每个子地图的位姿</strong>作为 “优化变量”，构建 “位姿图”。位姿图的 “约束” 来自两方面：</p>
<ul>
<li>相邻子地图之间的<strong>相对位姿观测</strong>（比如相邻子地图天然的位置关联）；</li>
<li>回环检测算出的<strong>子地图间相对位姿</strong>（比如S1和S2通过回环得到的关系）。</li>
</ul>
<p>以子地图1和2为例：假设回环检测算出它们的相对位姿是$T_{S_1S_2}$，那么 “误差残差e” 就是用这个观测值，对比子地图实际位姿（TWS1、TWS2）算出来的（公式。</p>
<script type="math/tex; mode=display">
e=Log(T_{WS_{1}}^{−1}T_{WS_2}T_{S_1S_2}^{-1})）</script><p>这里计算误差的 “雅可比矩阵”（描述变量变化对误差的影响）比较复杂，通常让程序自动求导即可。</p>
<p><strong>步骤 3：防止错误回环</strong></p>
<p>为了避免 “误判的回环”（把不是回环的情况当成回环），还要验证：<strong>修正后的累计误差不能太大</strong>，否则就把这个 “假回环” 当成 “异常值” 删掉，不参与优化。</p>
<p>简单说：回环修正靠 “位姿图优化子地图位姿”，约束来自 “相邻关系” 和 “回环检测结果”，同时还要过滤 “错误回环”。</p>
<h2 id="3D-SLAM"><a href="#3D-SLAM" class="headerlink" title="3D SLAM"></a>3D SLAM</h2><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/7_2扫描匹配.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/7_2扫描匹配.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h3 id="多线激光的Scan-Matching"><a href="#多线激光的Scan-Matching" class="headerlink" title="多线激光的Scan Matching"></a>多线激光的Scan Matching</h3><p>多线激光的扫描匹配效果通常好于单线激光，所以后端的处理要更加简单，大多数多线激光的 SLAM 系统都不使用子地图这样的概念，而是直</p>
<p>接<strong>管理点云本身</strong>。于是，点云的配准也主要以 scan to scan 或 scan to map 为主。</p>
<p>点云数量不一样时，ICP（迭代最近点）能实现配准，核心在于<strong>通过 “最近邻搜索” 动态建立点对关系</strong>，而不是依赖 “初始点数量相同、顺序对应”：</p>
<ol>
<li>动态找 “最近邻” 来配对</li>
</ol>
<p>对于点云S1中的<strong>每一个点</strong>pi，都去点云S2中找<strong>距离它最近的点</strong>qj，把(pi,qj)作为 “匹配点对”。</p>
<ul>
<li>哪怕S1和S2的总点数不同（比如S1有 100 个点，S2有 200 个点），也能为S1的每个点找到 “最近邻居”；</li>
<li>S2里的点可能被多个S1的点选为 “最近邻”，也可能有些点没被选中 —— 但这不影响，因为我们只需要 “当前迭代下，尽可能近的点对” 来计算变换。</li>
</ul>
<ol>
<li>用点对求变换，迭代优化</li>
</ol>
<p>有了这些 “最近邻点对” 后，就可以用<strong>最小二乘法</strong>等方法，求解让pi≈Rqj+t（旋转R、平移t）误差最小的变换。</p>
<p>然后，用这个变换调整其中一个点云（比如把S2按R,t变换），再重复 “找最近邻→求变换” 的过程，直到点云对齐得足够好（误差足够小或迭代次数足够）。</p>
<p><strong>举个例子</strong>：比如S1是物体 “正面扫描的 100 个点”，S2是 “侧面扫描的 200 个点”。ICP 会为S1的每个点，在S2里找最近的点（可能是侧面上的点），然后通过这些点对算 “旋转 + 平移”，把S2往S1的方向对齐；调整后再重新找最近邻，反复迭代，直到两个点云整体重合。</p>
<p>简言之：ICP 不要求点云 “点数相同、顺序对应”，而是靠 “动态找最近邻” 来建立临时点对，进而逐步优化配准。</p>
<h3 id="NDT方法"><a href="#NDT方法" class="headerlink" title="NDT方法"></a>NDT方法</h3><p>NDT（正态分布变换）是一种点云配准方法，核心是<strong>用 “统计信息（均值、方差）” 代替 “单个点” 来做匹配</strong>，步骤通俗易懂的解释如下：</p>
<p><strong>1.把目标点云 “切块”</strong></p>
<p>先把要配准到的目标点云，按固定分辨率分成很多小 “体素”（类似把蛋糕切成小块）。</p>
<p><strong>2.统计每个 “小块” 的分布</strong></p>
<p>每个体素里的点，会符合 “高斯分布”（可以理解为 “点的聚集规律”）。计算每个体素的<strong>均值</strong>（点的平均位置，记为μk）和<strong>方差</strong>（点的分散程度，记为Σk）。</p>
<p><strong>3.让待配准的点 “贴合统计规律”</strong></p>
<p>拿要配准的点云里的点$q_i$，用当前估计的 “旋转R + 平移t” 变换后，看它落到哪个体素里。然后用这个体素的均值μi，算 “残差”：$e_i=Rq_i+t−μ_i$（残差是 “变换后点的位置” 和 “体素均值” 的差距）。</p>
<p><strong>4. 优化旋转和平移，让残差最小</strong></p>
<p>通过<strong>高斯 - 牛顿（G-N）</strong>或<strong>列文伯格 - 马夸尔特（L-M）</strong>方法，最小化 “残差的加权和”（权重由体素方差的逆$Σi^{−1}$决定），找到最优的R和t。这相当于让变换后的点，尽可能符合目标体素的 “分布规律”，也就是<strong>最大化点落在对应体素里的概率</strong>（专业说法叫 “最大似然估计”）。</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/7_4激光里程计.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/7_4激光里程计.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=""></p>
<h3 id="直接法的激光里程计"><a href="#直接法的激光里程计" class="headerlink" title="直接法的激光里程计"></a>直接法的激光里程计</h3><p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911210904192.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250911210904192.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250911210904192"></p>
<ul>
<li><strong>直接法激光里程计</strong>：要么 “当前激光扫描和上一次的扫描直接对齐”；要么在 3D  场景下，把最近一段时间的点云凑成一个 “小局部地图”，再让当前新扫描的点云和这个小地图对齐。这种方法不用特意找  “点云里的特殊特征（比如尖角、平面）”，直接拿整点点云来匹配，还能基于 ICP 或 NDT 实现（看左侧流程图）。</li>
<li><strong>增量式 NDT</strong>：想更高效的话，不用每次都重新拼 “小局部地图”。而是把已经匹配好的点云，直接更新到  NDT 的 “小方块（体素）” 里，同时更新每个小方块内点的  “分布规律（比如点集中在哪里、分散程度如何）”。之后新的点云来匹配时，直接用这些更新好的小方块信息，不用反复建复杂的查找结构（比如 Kd  树这类帮快速找东西的索引），速度更快。接下来会实际做这两种 NDT，比比谁的计算效率更高。</li>
</ul>
<h3 id="特征法的激光里程计"><a href="#特征法的激光里程计" class="headerlink" title="特征法的激光里程计"></a>特征法的激光里程计</h3><p>简单来说，用 “特征法” 做激光雷达的 SLAM（定位 + 建图）时，要搞清楚两件事：多线激光雷达该提取什么样的 “特殊点（特征）”，以及怎么用这些特殊点让不同帧的点云对齐。</p>
<p>虽然点云特征有很多种（比如 <strong>PFH、FPFH，还有深度学习</strong>搞出来的），但<strong>实时 SLAM 里对特征有几个实用要求</strong>：</p>
<ol>
<li>特征得匹配激光点云的特点 —— 自动驾驶的激光点云是 “一束一束的线”（不像 RGB-D 相机点云那么密），所以不用对整个点云提取特征，针对<strong>每一条激光线上的点</strong>提取就行。</li>
<li>提取特征后，得能轻松用这些点做几何对齐（比如用之前讲的 ICP、NDT 这些方法）。</li>
<li>提取特征不能太费电脑资源（CPU/GPU 别过载），也别依赖特殊硬件（否则不好普及）。</li>
<li>整个系统（激光里程计或 SLAM）的计算要统一，别一部分在 CPU 跑、一部分在 GPU 跑，避免数据传来传去浪费资源。</li>
</ol>
<p>大部分系统会使用<strong>线束信息</strong>来进行特征提取。下面我们介绍类 LOAM 系统的特征提取方法。</p>
<p>多线激光雷达的点云自带 “线束” 相关信息，利用这些信息能提取有用特征，通俗解释如下：</p>
<h4 id="激光点的-“额外信息”-很有用"><a href="#激光点的-“额外信息”-很有用" class="headerlink" title="激光点的 “额外信息” 很有用"></a>激光点的 “额外信息” 很有用</h4><p>从多线激光雷达得到的点，除了位置（x,y,z），还能知道：</p>
<ul>
<li>这个点来自<strong>哪条激光扫描线</strong>；</li>
<li>同一条扫描线上，点的<strong>先后顺序</strong>；</li>
<li>甚至能拿到<strong>极坐标角度、扫描时间</strong>等精细信息。</li>
</ul>
<p>这些信息能帮上大忙：比如不用费力去找 “同一条线上点的最近邻居”；还能通过 “<strong>曲率</strong>”（同一条线上，一个点和周围点的偏离程度）判断点的类型。</p>
<h4 id="用-“曲率”-挑-“角点-平面点”"><a href="#用-“曲率”-挑-“角点-平面点”" class="headerlink" title="用 “曲率” 挑 “角点 / 平面点”"></a>用 “曲率” 挑 “角点 / 平面点”</h4><ul>
<li>若曲率<strong>大</strong>（点和周围点偏离多），说明是<strong>角点</strong>（比如垂直物体表面、两个平面的交界点）；</li>
<li>若曲率<strong>小</strong>（点和周围点偏离少），说明是<strong>平面点</strong>（比如大平面上的点）。</li>
</ul>
<p>像 LOAM 系列算法，就靠这招挑特征点：角点适合用 “<strong>点到线</strong>” 的 ICP 配准，平面点适合用 “<strong>点到面</strong>” 的 ICP 配准（如图，左侧两点成直线对应角点，右侧三点成平面对应平面点）。</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250912111528944.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20250912111528944.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20250912111528944"></p>
<h4 id="适用范围与局限性"><a href="#适用范围与局限性" class="headerlink" title="适用范围与局限性"></a>适用范围与局限性</h4><ul>
<li>这种思路也能用于<strong>2D 激光雷达</strong>；还有其他提取方法，比如 LGoLOAM 用 “距离图像” 提地面点、角点，mulls 用 PCA（主成分分析）提地面、立面等。</li>
<li>但这类方法很 “<strong>工程化</strong>”—— 依赖雷达的 “先天信息”（比如有多少条扫描线、激光是否水平放置），不同雷达得针对性调整。</li>
<li>而且，<strong>RGB-D 相机的点云</strong>没有激光 “线束” 这类信息，所以这类方法在 RGB-D 场景下用不了，限制了使用范围。</li>
</ul>
<p>特征提取的算法主要包括几个部分：</p>
<ol>
<li><p>计算每个点的线束并归类。由于我们在点云中已携带了这部分信息，这步可以跳过。</p>
</li>
<li><p>依次计算线束中每个点的曲率。</p>
</li>
<li><p>把点云按一周分成若干个区间（实现当中取 6 个区间）。选择其中曲率最大的若干个点作</p>
</li>
</ol>
<p>​    为角点。剩余的点作为平面点。</p>
<h2 id="松耦合LIO系统"><a href="#松耦合LIO系统" class="headerlink" title="松耦合LIO系统"></a>松耦合LIO系统</h2><p>松耦合 LIO（激光雷达 - 惯性里程计）系统，是激光雷达与 IMU（惯性测量单元）“间接配合” 的定位方式，核心逻辑是 <strong>“各算各的结果，再融合”</strong>，通俗解释如下：</p>
<h4 id="分工计算"><a href="#分工计算" class="headerlink" title="分工计算"></a>分工计算</h4><ul>
<li>IMU（结合轮速）负责提供 <strong>“惯性层面的运动趋势”</strong>：比如 IMU 测量角速度、加速度，反映机器人运动的 “动态变化（比如加速、转弯）”；</li>
<li>激光雷达负责通过<strong>点云匹配（如 ICP、NDT 等方法）</strong>，算出 <strong>“位姿变化的最终结果”</strong>（机器人走了多远、转了多少角度）。</li>
</ul>
<h4 id="融合逻辑：“结果级融合”，而非-“细节级融合”"><a href="#融合逻辑：“结果级融合”，而非-“细节级融合”" class="headerlink" title="融合逻辑：“结果级融合”，而非 “细节级融合”"></a>融合逻辑：“结果级融合”，而非 “细节级融合”</h4><p>系统有个 “状态估计器”（比如卡尔曼滤波器），用来综合判断机器人的位置、姿态。松耦合的特点是：<strong>不把点云匹配时的 “细节误差”（比如点和线、点和面的匹配误差）直接塞进估计器</strong>，而是把激光雷达 “点云匹配好的最终位姿结论” 交给估计器。</p>
<p>这样一来，激光的 “点云匹配部分” 和估计器的 “卡尔曼滤波部分” 是<strong>相对独立的（解耦的）</strong>，实现起来更简单。</p>
<h4 id="双向互助，但有局限"><a href="#双向互助，但有局限" class="headerlink" title="双向互助，但有局限"></a>双向互助，但有局限</h4><ul>
<li>点云匹配时，能拿 “状态估计器预测的位姿” 当 <strong>“初始猜测”</strong>，让点云更快对齐；</li>
<li>但如果激光点云的环境很差（比如全是平地，没明显特征），点云匹配会不准，反过来也会影响 “状态估计器” 的准确性。</li>
</ul>
<h4 id="对比与实现：简单易上手"><a href="#对比与实现：简单易上手" class="headerlink" title="对比与实现：简单易上手"></a>对比与实现：简单易上手</h4><p>和 “紧耦合”（把点云匹配的<strong>细节误差</strong>直接融入滤波，更复杂）相比，松耦合结构简单，适合学习。文中用 “第 3 章的 ESKF（一种卡尔曼滤波） + 增量 NDT（激光点云匹配方法）” 来实现，你也可以把激光匹配换成 ICP 或 “基于特征的方法”。</p>
<h2 id="紧耦合LIO系统"><a href="#紧耦合LIO系统" class="headerlink" title="紧耦合LIO系统"></a>紧耦合LIO系统</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>松耦合：“各干各的，只交结果”</strong></p>
<p>每个传感器像 “独立工作的人”，自己把任务做完，只把<strong>最终结果</strong>交给系统汇总。比如激光雷达自己算 “机器人走了多远、转了多少”，IMU 自己算 “运动的加速度、角速度趋势”，最后系统把这两个结果 “拼起来”。</p>
<p>如果其中一个人（比如激光雷达遇到全是平地，没东西可测）“工作失误”，系统得先 “发现他失误了”，才能想办法补救。</p>
<p><strong>紧耦合：“互相看细节，实时帮忙”</strong></p>
<p>不只是要 “最终结果”，还要看<strong>工作过程中的细节</strong>。比如关注 IMU 测量时的 “小误差（零偏）”“噪声”，或者激光雷达点云匹配时的 “误差细节”。把这些 “精细信息” 都整合到系统里，相当于团队成员之间 “实时看对方的工作细节，互相纠正”。</p>
<p><strong>紧耦合的好处：“一个不行， others 能兜底”</strong></p>
<p>如果某个传感器（比如激光雷达遇到没特征的场景，快算错了）状态不好，紧耦合因为能拿到 “细节”，其他传感器（比如 IMU）能<strong>实时约束它</strong>，不让它乱算；反过来 IMU 自己容易 “漂移（误差越攒越多）”，激光的细节也能拉着 IMU 别跑偏。</p>
<p>而松耦合下，一个传感器失效了，系统得先 “识别出失效” 才能处理；紧耦合是 “从根上（细节里）就互相约束”，就算一个传感器状态差，其他传感器能靠细节把它 “拽回正轨”，系统整体更稳定。</p>
<h3 id="基于IEKF的LIO系统"><a href="#基于IEKF的LIO系统" class="headerlink" title="基于IEKF的LIO系统"></a>基于IEKF的LIO系统</h3><p>IEKF（迭代扩展卡尔曼滤波器）在紧耦合 LIO（激光雷达 - 惯性里程计）系统里，是用来<strong>融合激光雷达和 IMU 数据，精准估计机器人状态</strong>的工具，核心逻辑通俗拆解如下：</p>
<h4 id="估计的-“核心状态”（状态变量）"><a href="#估计的-“核心状态”（状态变量）" class="headerlink" title="估计的 “核心状态”（状态变量）"></a>估计的 “核心状态”（状态变量）</h4><p>把机器人的关键状态打包成一个集合，定义一个高维流行空间$\mathcal{M}$包括：</p>
<script type="math/tex; mode=display">
x = \left[ p, v, R, b_g, b_a, g \right]^\top \in \mathcal{M}</script><p>按照陀螺仪和加速度计的读数，离散时间对状态进行递推。 </p>
<script type="math/tex; mode=display">
\begin{align*}
\boldsymbol{p}(t+\Delta t) &= \boldsymbol{p}(t) + \boldsymbol{v}\Delta t + \frac{1}{2} \bigl( \boldsymbol{R}(\tilde{\boldsymbol{a}} - \boldsymbol{b}_a) \bigr) \Delta t^2 + \frac{1}{2} \boldsymbol{g}\Delta t^2, \\
\boldsymbol{v}(t+\Delta t) &= \boldsymbol{v}(t) + \boldsymbol{R}(\tilde{\boldsymbol{a}} - \boldsymbol{b}_a)\Delta t + \boldsymbol{g}\Delta t, \\
\boldsymbol{R}(t+\Delta t) &= \boldsymbol{R}(t)Exp\bigl( (\tilde{\boldsymbol{\omega}} - \boldsymbol{b}_g)\Delta t \bigr), \\
\boldsymbol{b}_g(t+\Delta t) &= \boldsymbol{b}_g(t), \\
\boldsymbol{b}_a(t+\Delta t) &= \boldsymbol{b}_a(t), \\
\boldsymbol{g}(t+\Delta t) &= \boldsymbol{g}(t).
\end{align*}</script><h4 id="IMU-如何-“推算”-状态变化（运动方程）"><a href="#IMU-如何-“推算”-状态变化（运动方程）" class="headerlink" title="IMU 如何 “推算” 状态变化（运动方程）"></a>IMU 如何 “推算” 状态变化（运动方程）</h4><p> IMU 会实时测<strong>角速度</strong>（转多快）和<strong>加速度</strong>（跑多快）。从当前时刻t到下一时刻t+Δt，机器人的状态会这样更新：</p>
<h4 id="误差的-“传播”（不确定性管理）"><a href="#误差的-“传播”（不确定性管理）" class="headerlink" title="误差的 “传播”（不确定性管理）"></a>误差的 “传播”（不确定性管理）</h4><p>IMU 测量有 “噪声”（不准的成分），所以每次推算后，状态的 “不确定性”（用 <strong> 方差P</strong> 表示）会变化。公式里用矩阵F和噪声矩阵Q，算出推算后新的 “不确定性”，为后续和激光数据融合做准备。</p>
<h4 id="激光与-IMU-的-“时间差”-处理"><a href="#激光与-IMU-的-“时间差”-处理" class="headerlink" title="激光与 IMU 的 “时间差” 处理"></a>激光与 IMU 的 “时间差” 处理</h4><p>激光雷达的刷新频率比 IMU 低（比如 IMU 每秒测几百次，激光每秒只测几十次）。所以两次激光数据之间，会有很多 IMU 的读数，这时候就用上面的运动方程<strong>多次推算</strong>，把 IMU 的连续数据都利用起来，得到 “推算后的状态xpred” 和 “不确定性Ppred”，方便后续和激光数据融合。</p>
<h3 id="IEKF"><a href="#IEKF" class="headerlink" title="IEKF"></a>IEKF</h3><p>现实中大部分系统都是<strong>非线性</strong>的（比如雷达测距离：距离 =√(x²+y²)，带平方根；卫星定位中速度和位置的关系也不是直线），而普通 KF 只能处理<strong>线性系统</strong>（比如 “速度 = 加速度 × 时间” 这种 y=ax+b 的关系）。</p>
<p>为了处理非线性系统，人们发明了<strong>EKF（扩展卡尔曼滤波）</strong>：把非线性函数在 “当前估计值” 附近用 “泰勒展开” 掰直（线性化），再用 KF 的逻辑计算。但 EKF 有个致命问题 ——<strong>只线性化一次</strong>，如果非线性很强（比如曲线很陡），“掰直” 的误差会很大，导致估计不准。</p>
<p>这时候<strong>IEKF（迭代卡尔曼滤波）</strong> 就登场了：它在 EKF 的基础上，把 “线性化→更新估计” 的过程<strong>重复好几次</strong>（迭代），每次都用 “最新的估计值” 重新线性化，直到估计值变化很小（收敛），从而减小线性化误差，让结果更准。</p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="CH2"><a href="#CH2" class="headerlink" title="CH2"></a>CH2</h2><p>1、</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20251031211953425.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20251031211953425.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20251031211953425" style="zoom:33%;" /></p>
<p>3、</p>
<p><img src="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20251031211904911.png" class="lazyload placeholder" data-srcset="https://ghigher-picture-bed.oss-cn-qingdao.aliyuncs.com/img_for_typora/image-20251031211904911.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20251031211904911" style="zoom: 33%;" /></p>

      </div>
      <div class="post-tags-categories">
        
        <div class="tags">
          
            <a href="/tags/SLAM/" class="">
              SLAM
            </a>
          
        </div>
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Ychui</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2025/11/14/激光slam学习记录一/" target="_blank" title="激光slam学习记录一">https://yuchanghui.top/2025/11/14/激光slam学习记录一/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">





  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="/medias/7.jpg" class="lazyload placeholder" data-srcset="/medias/7.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" src="" alt="">
    </div>
    <a href="/2025/11/14/%E6%AD%A5%E7%A7%91%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BACanopen%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">步科伺服电机Canopen协议驱动</div>
      </div>
      <!-- <div class="content">
        KincoServo软件控制硬件
软件操作KincoServo+连接设备

设备控制

在基本操作中进行工作模式，速度等
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    
      <div id="appDonate" class="post-donate">
  <div id="donate_board" class="donate_bar center" ref="donate">
    <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏" @click="showDialogDrawer()"></a>
  </div>
  <transition name="fade">
    <div 
      class="donate-box-mask"
      v-cloak 
      v-show="visible"
      @click="cancelDialogDrawer()"
    >
    </div>
  </transition>
  <transition name="bounce">
    <div class="donate-box" v-cloak v-show="visible">
      <div class="donate-box_close">
        <i class="fas fa-times" aria-hidden="true" @click="cancelDialogDrawer" pointer></i>
      </div>
      <div class="donate-box_title">
        <h4>
          你的赏识是我前进的动力
        </h4>
      </div>
      <div class="donate-box_tab">
        <div class="Alipay" pointer :class="{'active': tabActive === 'Alipay'}" @click="changeTabActive('Alipay')">
          支付宝
        </div>
        <div class="WeChatpay" pointer :class="{'active': tabActive === 'WeChatpay'}" @click="changeTabActive('WeChatpay')">
          微信
        </div>
      </div>
      <div class="donate-box_img">
        <div class="AlipayImg" v-show="tabActive === 'Alipay'">
          <img src="/medias/alipay.png" class="lazyload placeholder" data-srcset="/medias/alipay.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="支付宝打赏" />
        </div> 
        <div class="WeChatpayImg" v-show="tabActive === 'WeChatpay'">
          <img src="/medias/wechatpay.png" class="lazyload placeholder" data-srcset="/medias/wechatpay.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="微信打赏" />
        </div>
      </div>
    </div>
  </transition>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDonate',
    data: {
      visible: false,
      tabActive: 'Alipay',
      top: 0,
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        // function getScroll() {
        //   return {
        //     left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
        //     top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
        //   };
        // }
        this.top = $(document).scrollTop() // or getScroll().top
        // console.log('aa', $('.main-content'));
        body.style.cssText = 'overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
      changeTabActive(name) {
        this.tabActive = name;
      }
    },
    created() {}
  })
</script>
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      
<section id="comments" style="padding: 1em; margin: 15px auto;"
	class="animated bounceInUp">
	<div id="vcomment" class="comment"></div>
</section>
<style>
	#comments {
		background: rgba(255,255,255,0.9);
	}
	#veditor {
		background-image: url('/medias/monkey.gif');
		background-size: contain;
		background-repeat: no-repeat;
		background-position: right;
		background-color: rgba(255, 255, 255, 0);
		resize: vertical;
	}
	#veditor:focus{
		background-position-y: 200px;
		transition: all 0.2s ease-in-out 0s;
	}
	#vcomment .vcards .vcard .vh .vhead .vtag.vvisitor {
		background-color: #42b983;
	}
	.v[data-class=v] .vbtn:active, .v[data-class=v] .vbtn:hover {
		color: #42b983;
		border-color: #42b983;
	}
	#vcomment .vcards .vcard .vhead .vsys i {
		display: none;
	}
	/* 底部valine链接 */
	#vcomment .vpower {
		display: none;
	}
	
	/* 底下注释是修改 名称和邮箱和网址输入框的样式 */
	/* #vcomment .vheader {
		display: flex;
		justify-content: space-around;
	}
	
	#vcomment .vheader .vnick {
		width: 31%;
		border: 2px solid #dedede;
		padding-left: 10px;
		padding-right: 10px;
		border-radius: 5px
	}

	#vcomment .vheader .vmail {
		width: 31%;
		border: 2px solid #dedede;
		padding-left: 10px;
		padding-right: 10px;
		border-radius: 5px
	}

	#vcomment .vheader .vlink {
		width: 31%;
		border: 2px solid #dedede;
		padding-left: 10px;
		padding-right: 10px;
		border-radius: 5px
	} */

	img.vimg {
		transition: all 1s;
		/* 头像旋转时间为 1s */
	}

	img.vimg:hover {
		transform: rotate(360deg);
		-webkit-transform: rotate(360deg);
		-moz-transform: rotate(360deg);
		-o-transform: rotate(360deg);
		-ms-transform: rotate(360deg);
	}

	#vcomment .vcards .vcard {
		padding: 15px 20px 0 20px;
		border-radius: 10px;
		margin-bottom: 15px;
		box-shadow: 0 0 4px 1px rgba(0, 0, 0, .12);
		transition: all .3s
	}

	#vcomment .vcards .vcard:hover {
		box-shadow: 0 0 8px 3px rgba(0, 0, 0, .12)
	}

	#vcomment .vcards .vcard .vh .vcard {
		border: none;
		box-shadow: none;
	}
</style>
    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <!-- 文章详情页右侧目录 -->

  <div class="toc-aside">
    <div class="toc-main">
      <div class="toc-aside-title">
        <i class="fas fa-list-ul" aria-hidden="true"></i><span>本文目录</span>
        
          <div class="toc-open-close">本文目录</div>
        
      </div>
      <div class="toc-content">
        <div class="toc"></div>
      </div>
    </div>
  </div>

  <!-- 手机端目录按钮 -->
  <div id="toc-mobile-btn">
    <i class="fas fa-list-ul" aria-hidden="true"></i>
  </div>


<script>
  function closeToc(init) {
    $(".toc-aside").css({'width': 0, 'padding': 0, 'transition': init ?  'noe' : 'width 0.3s' });
    $(".toc-content").css({'width': 0});
    $(".toc-aside-title span, .toc-aside-title i").css({'display': 'none'});
    $(".main-content").css({'width': '75%', 'margin': '10px auto'});
  };
  function openToc() {
    $(".main-content").css({'width': '65%', 'margin-right': '10px', 'margin-left': 'calc(35% - 350px)'});
    $(".toc-aside").css({'width': '300px', 'padding': '0 10px', 'transition': 'width 0.3s'});
    $(".toc-content").css({'width': '300px'});
    $(".toc-aside-title span, .toc-aside-title i").css({'display': 'inline-block'});
  }
  function openBtnClickFn () {
    let openOrCloseBtn = $('.toc-aside .toc-aside-title .toc-open-close');
    let open = eval('' || 'true');
    openOrCloseBtn.click(function() {
      if (open) {
        closeToc();
        open = false;
      } else {
        openToc();
        open = true;
      }
    });
  };
  openBtnClickFn();
  initCloseTocWidth(true);

  function initCloseTocWidth(init) {
    if (window.innerWidth >= 992) {
      let isClose = false;
      isClose && closeToc(init)
    }
  }

  document.addEventListener('pjax:complete', function () {
    $(".toc-aside").css({'transition': 'no'});
  })
  document.addEventListener('pjax:complete', function () {
    openBtnClickFn();
  })
  
</script>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


                            </main>
                          </div>

                          <!-- 页脚 -->
                          
  
  <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = 'rgba(45, 46, 54, 0.8)' || '#2c2c2c';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



                            <!-- 渲染暗黑按钮 -->
                            
                              <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
                                
                                  <!-- 渲染回到顶部按钮 -->
                                  
                                    <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

                                      
                                        <!-- 渲染左下角音乐播放器 -->
                                        
                                          <link rel="stylesheet" href="/js/aplayer/APlayer@1.10.1.min.css">
<style>
.aplayer .aplayer-lrc p {
  
  font-size: 12px;
  font-weight: 700;
  line-height: 16px !important;
}

.aplayer .aplayer-lrc p.aplayer-lrc-current {
  
  font-size: 15px;
  color: #2c2c2c;
}


.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
  left: -66px !important;
}

.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
  left: 0px !important;
}


</style>
<meting-js  
  class=""
  server="netease"
  type="playlist"
  id="8934224878"
  fixed='true'
  autoplay='true'
  theme='#2c2c2c'
  loop='all'
  order='list'
  preload='auto'
  volume='0.75'
  list-folded='true'
>
</meting-js>

<!-- <style>
  #aplayer {
    position: fixed;
    left: 0;
    bottom: 300px;
  }
</style> -->
<script src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
<script src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
                                            

                                              <!-- 图片放大 -->
                                              
                                                <script
                                                  src="/js/fancybox/jquery.fancybox.min.js"></script>
                                                

                                                  <!-- 百度解析 -->
                                                  <!-- Baidu Analytics -->

                                                    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


                                                      <!-- 背景彩带 -->
                                                      

                                                          
                                                            <script type="text/javascript" color="0,0,0" opacity='0.6'
                                                              zIndex="-1" count="99"
                                                              src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
                                                            

                                                              <script
                                                                src="/js/utils/index.js"></script>
                                                              <script src="/js/app.js"></script>

                                                              <!-- 文章目录所需js -->
<link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script>

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -80,
    headingsOffset: -($(window).height() * 0.4 - 45),
    positionFixedSelector: '.toc-main',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 100) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('toc-aside')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  }
</style> 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const headerMenuTransparent = true;
    if (!headerMenuTransparent) { return; }
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <!-- 弹幕所需的css和js -->
    
  <!-- 弹幕插件 -->
  <link href="/js/danmu/barrager.css" rel="stylesheet">
  <script src="/js/danmu/jquery.barrager.js"></script>

<!-- 具体js，请前往valine/script.ejs查看 -->

    <script>
  var requiredFields = '';
  requiredFields = requiredFields.split(',');
  comment_el = '.comment';
  let looperValine = null;
  load_valine = function () {
    if ($(comment_el).length) {
      var valine = new Valine({
        el: '#vcomment',
        path: window.location.pathname,
        notify: false,
        verify: false,
        app_id: "2PVPHuivtIxkhlA1Kv1quvq2-gzGzoHsz",
        app_key: "7EDHPdniI5WQBAkU96Yxy9bG",
        placeholder: "说点什么吧",
        avatar: "",
        master: "9b1cd4514cf4b7b3747b9aaa3b78397f",   //博主邮箱md5
        tagMeta: ["博主","小伙伴","访客"],     //标识字段名
        friends: "",
        metaPlaceholder: { "nick": "昵称/QQ号", "mail": "邮箱" },
        requiredFields: requiredFields,
        enableQQ: true,
      });
      function debounce(fn) {
        var timerID = null
        return function () {
          var arg = arguments[0]   //获取事件
          if (timerID) {
            clearTimeout(timerID)
          }
          timerID = setTimeout(function () {
            fn(arg)              //事件传入函数
          }, 200)
        }
      }
      //查询评论 valine.Q('*').limit(7) -- 查询所有，限制7条, 下面的的代码是查询当前页面
      var themeDanmu = eval('true');
      var themeLoop = eval('false');
      var themeLooperTime = '5000' || 5000;
      var speed = '40' || 20;
      var isBarrager = true;
      if (themeDanmu == true) {
        do_barrager();
        if ($('.danmuBox').length <= 0) {
          $('.navbar').append('<div class="danmuBox"><div class="danmuBtn open"><span class="danmuCircle"></span><span class="danmuText">弹幕</span></div></div>');
        }
        $('.danmuBtn').on('click', debounce(
          function () {
            if ($('.danmuBtn').hasClass('open')) {
              $('.danmuBtn').removeClass('open')
              clearInterval(looperValine);
              $.fn.barrager.removeAll();
            } else {
              $('.danmuBtn').addClass("open");
              do_barrager();
            }
          }
        ))
      }
      function do_barrager() {
        isBarrager && valine.Q(window.location.pathname).find().then(function (comments) {
          // var num = 0; // 可以记录条数，循环调用的时候只取最新的评论放入弹幕中
          var run_once = true;
          var looper_time = themeLooperTime;
          var total = comments.length;
          // var looper = null;
          var index = 0;
          if (total > 0) {
            barrager();
          } else {
            // 当评论数为0的时候，自动关闭弹幕
            // $('.danmuBtn').removeClass('open');
          }
          function barrager() {
            if (run_once) {
              //如果是首次执行,则设置一个定时器,并且把首次执行置为false
              looperValine = setInterval(barrager, looper_time);
              run_once = false;
            }
            var content = comments[index]._serverData.comment;
            var email = comments[index]._serverData.mail;
            var link = comments[index]._serverData.link;
            var newcontent = content.substring(0, 50).replace(/<[^>]+>/g, "");
            //发布一个弹幕
            const item = {
              img: `https://q1.qlogo.cn/g?b=qq&nk=${email}&s=640`, //图片 
              info: newcontent, //文字 
              href: link, //链接 
              close: true, //显示关闭按钮 
              speed: speed, //延迟,单位秒,默认6 
              color: '#fff', //颜色,默认白色 
              old_ie_color: '#000000', //ie低版兼容色,不能与网页背景相同,默认黑色
            }
            $('body').barrager(item);
            //索引自增
            index++;
            //所有弹幕发布完毕，清除计时器。
            if (index == total) {
              clearInterval(looperValine);
              if (themeLoop === true) {
                setTimeout(function () {
                  do_barrager();
                }, 5000);
              } else {
                $('.danmuBtn').removeClass('open');
              }
              return false;
            }

          }
        })
      }
    }
  };
  $(document).ready(load_valine);
  document.addEventListener('pjax:send', function (e) {
    
      $('.danmuBox').length > 0 && $('.danmuBox').remove()
      looperValine && clearInterval(looperValine);
      $.fn.barrager.removeAll();
    
  })
  document.addEventListener('pjax:complete', function () {
    load_valine();
  });
</script>

  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


                                                                <!-- pjax -->
                                                                

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



                  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>